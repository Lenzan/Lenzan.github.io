<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unity3D UGUI中将Text的内容复制到粘贴板</title>
    <url>/2018/05/13/Unity/Copy/</url>
    <content><![CDATA[<a id="more"></a>
<p>首先要考虑不同的平台之间的差别 pc 端最简单，移动端需要交互，掉用自己的 copy 方法<br>先写一段代码 pc 端的</p>
<pre><code>using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System;

public class CopyText : MonoBehaviour ,IPointerClickHandler
&#123;
     public Text messageText;//创建出来的消息显示的text
     
     public void OnPointerClick(PointerEventData eventData)
     &#123;
        TextEditor te = new TextEditor();
        te.text = messageText.text;
        te.OnFocus();
        te.Copy();
     &#125;
     
&#125;
</code></pre>
<p>将脚本放到 Text 物体上就可以了，随后会更新移动端的剪切方式，有什么不懂得地方可以留言。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D-UI框架</title>
    <url>/2018/08/15/Unity/UIManager/</url>
    <content><![CDATA[<p>博主的小游戏开发已经正式开展了起来了，游戏的定位主要就是乱斗游戏，首先就是通过写文章来记录一下自己游戏开发中遇到的问题，难点什么的。废话不多说直接进主题。</p>
<h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3><p>游戏的开始当然是要先做界面了，研究了几天弄了个 UI 框架，主要功能就是由 UIManager 来控制界面的显隐，层级，界面导航的功能，</p>
<h3 id="BaseUI-基类"><a href="#BaseUI-基类" class="headerlink" title="BaseUI 基类"></a>BaseUI 基类</h3><p>我们先定义一个基类，所有需要通过 UIManager 控制的面板都必须继承这个基类。这个基类里面主要功能就是此界面的显隐方法，当前的层级，当前界面显示的上个界面，界面的类型等等。</p>
<pre><code>//UI界面的基类
public class BaseUI : MonoBehaviour &#123;
    public UIType uiType = new UIType();
    protected EUiId uiId = EUiId.NullUI;
    protected EUiId beforeuiId = EUiId.NullUI;
    private int currentDepth = 1;

    public int CurrentDepth
    &#123;
        get
        &#123;
            return currentDepth;
        &#125;

        set
        &#123;
            currentDepth = value;
        &#125;
    &#125;
    public EUiId GetUiId
    &#123;
        get
        &#123;
            return uiId;
        &#125;
    &#125;
    public EUiId GetBeforeuiId
    &#123;
        get
        &#123;
            return beforeuiId;
        &#125;
    &#125;

    public bool IsNeedUpdateStack
    &#123;
        get
        &#123;
            if (uiType.rootType == EUIRootType.KeepAbove)
            &#123;
                return false;
            &#125;
            if (uiType.showMode == EShowUIMode.NoReturn)
            &#123;
                return false;
            &#125;
            return true;
        &#125;

    &#125;
    protected Transform thisTrans;
    protected virtual void Awake()
    &#123;
        thisTrans = this.transform;
        InitUIOnAwake();
    &#125;

    public virtual void InitUIOnAwake()
    &#123;

    &#125;
    public virtual void InitUIData()
    &#123;
        if (uiType == null)
        &#123;
            uiType = new UIType();
        &#125;
    &#125;

    public virtual void ShowUI()
    &#123;
        this.gameObject.SetActive(true);
    &#125;

    public virtual void HideUI(DelAfterHideUI del)
    &#123;
        this.gameObject.SetActive(false);
        if (del != null)
        &#123;
            del();
        &#125;
    &#125;

    public virtual void DestroyUI()
    &#123;
        BeforeDestroy();
        Destroy(this.gameObject);
    &#125;

    protected virtual void BeforeDestroy()
    &#123;

    &#125;
&#125;
</code></pre>
<h3 id="类型-预制的映射"><a href="#类型-预制的映射" class="headerlink" title="类型/预制的映射"></a>类型/预制的映射</h3><p>主要是记录一下，需要加载面板的路径。</p>
<pre><code>//UI类型对应的本地保存文件的名字
    public static Dictionary&lt;EUiId, string&gt; dicName = new Dictionary&lt;EUiId, string&gt;()
    &#123;
        &#123; EUiId.LoginUI,&quot;UIPanel/LoginUI&quot; &#125;,
        &#123; EUiId.MainUI,&quot;UIPanel/MainUI&quot;&#125;,
        ...
    &#125;;
</code></pre>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><pre><code>public enum EShowUIMode//显示UI的模式
&#123;
    DoNothing,
    HideOther,//显示自己，隐藏其他的
    NoReturn//不需要反向切换
&#125;
</code></pre>
<h3 id="UI-类型"><a href="#UI-类型" class="headerlink" title="UI 类型"></a>UI 类型</h3><pre><code>public enum EUiId//UI类型
&#123;
    NullUI,
    LoginUI,
    MainUI,
    ...
&#125;
</code></pre>
<h3 id="界面的节点"><a href="#界面的节点" class="headerlink" title="界面的节点"></a>界面的节点</h3><pre><code>public enum EUIRootType//UI父节点
&#123;
    KeepAbove,//保持在最上方
    Normal,//普通UI
&#125;
</code></pre>
<h3 id="UI-类型-1"><a href="#UI-类型-1" class="headerlink" title="UI 类型"></a>UI 类型</h3><pre><code>public class UIType
&#123;
    public bool isResetReturnUIInfor = false;
    public EUIRootType rootType = EUIRootType.Normal;
    public EShowUIMode showMode = EShowUIMode.DoNothing;
&#125;
</code></pre>
<h3 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a>UIManager</h3><p>UI 控制UI面板的逻辑的东西都在这里面</p>
<pre><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class UIReturnInfor
&#123;
    public BaseUI willBeShowUI;
    public List&lt;EUiId&gt; listReturn;
&#125;
public class UIManager : MonoBehaviour
&#123;
    public static UIManager instance = null;//单例
    private Dictionary&lt;EUiId, BaseUI&gt; dicAllUI;//保存所有的UI

    private Dictionary&lt;EUiId, BaseUI&gt; dicShowUI;//保存正在显示的UI

    private Stack&lt;UIReturnInfor&gt; stackReturnInfor;

    private BaseUI currentUI;//当前显示的UI
    private BaseUI beforeUI;//上一个显示的UI
    public RectTransform uiRootTrans;//UI父节点
    public RectTransform keepAboveUIRoot;//保持在上面的UI的父节点
    public RectTransform normalUIRoot;//常规显示的UI的父节点

    //private int keepAboveUIRootDepth = 300;
    //private int normalUIRootDepth = 100;

    void Awake()
    &#123;
        if (instance == null)
        &#123;
            instance = this;
        &#125;
        if (dicAllUI == null)
        &#123;
            dicAllUI = new Dictionary&lt;EUiId, BaseUI&gt;();
        &#125;
        if (dicShowUI == null)
        &#123;
            dicShowUI = new Dictionary&lt;EUiId, BaseUI&gt;();
        &#125;
        if (stackReturnInfor == null)
        &#123;
            stackReturnInfor = new Stack&lt;UIReturnInfor&gt;();
        &#125;
        InitUIManager();
    &#125;

    //初始化
    public void InitUIManager()
    &#123;
        if (dicAllUI != null)
        &#123;
            dicAllUI.Clear();
        &#125;
        if (dicShowUI != null)
        &#123;
            dicShowUI.Clear();
        &#125;
        DontDestroyOnLoad(uiRootTrans);
        //ShowUI(EUiId.LoginUI);
    &#125;
    //根据UI类型显示UI
    public void ShowUI(EUiId uiId)
    &#123;
        BaseUI baseUI = JudgeShowUI(uiId);//判断Uiid是否已经显示出来了
        if (baseUI != null)
        &#123;
            baseUI.ShowUI();
            dicShowUI[uiId] = baseUI;
            if (baseUI.uiType.isResetReturnUIInfor)
            &#123;
                ClearStackReturnInfor();
            &#125;
        &#125;
        else
        &#123;
            return;
        &#125;
        if (baseUI.uiType.rootType == EUIRootType.Normal)
        &#123;
            beforeUI = currentUI;
            currentUI = baseUI;
        &#125;

    &#125;

    public BaseUI JudgeShowUI(EUiId uiId)
    &#123;
        //判断uiid 是不是已经显示出来了
        if (dicShowUI.ContainsKey(uiId))
        &#123;
            return null;
        &#125;
        BaseUI baseUI = GetBaseUI(uiId);
        //如果baseUI在dicAllUI里面没有找到说明这个窗体还没有被加载过
        if (baseUI == null)
        &#123;
            //加载
            if (GameDefine.dicName.ContainsKey(uiId))
            &#123;
                GameObject theUI = CorResMgr.Get().LoadResOnly(GameDefine.dicName[uiId]) as GameObject;
                theUI.name = uiId.ToString();
                if (theUI != null)
                &#123;
                    GameObject willShowUI = Instantiate(theUI);
                    willShowUI.SetActive(true);

                    //把窗体放到对应的节点下面
                    baseUI = willShowUI.GetComponent&lt;BaseUI&gt;();
                    RectTransform theRoot = GetTheRoot(baseUI);
                    GameTool.AddChildToParent(theRoot, willShowUI.GetComponent&lt;RectTransform&gt;());
                    theUI = null;
                    dicAllUI[uiId] = baseUI;
                &#125;
                else
                &#123;
                    Debug.Log(&quot;UIManager &gt;&gt; &quot; + &quot;you want to load UI no found...&quot;);
                &#125;
            &#125;
        &#125;
        UpdateStack(baseUI);
        return baseUI;

    &#125;

    public void ClearStackReturnInfor()
    &#123;
        if (stackReturnInfor != null)
        &#123;
            stackReturnInfor.Clear();
        &#125;
    &#125;

    private void UpdateStack(BaseUI baseUI)
    &#123;
        if (baseUI.IsNeedUpdateStack)
        &#123;
            //将要移除的窗体ID列表
            List&lt;EUiId&gt; removeKey = null;
            //存放需要添加进栈的窗体列表
            List&lt;BaseUI&gt; maxToMinUI = new List&lt;BaseUI&gt;();
            //存放根据depth值 从大到小排序好的窗体列表
            List&lt;EUiId&gt; newList = new List&lt;EUiId&gt;();
            UIReturnInfor uiReturnInfor = new UIReturnInfor();

            if (dicShowUI.Count &gt; 0)
            &#123;
                foreach (KeyValuePair&lt;EUiId, BaseUI&gt; item in dicShowUI)
                &#123;
                    if (item.Value.uiType.rootType != EUIRootType.KeepAbove)
                    &#123;
                        item.Value.HideUI(null);
                        if (removeKey == null)
                        &#123;
                            removeKey = new List&lt;EUiId&gt;();
                        &#125;
                        removeKey.Add(item.Key);
                    &#125;
                    if (item.Value.IsNeedUpdateStack)
                    &#123;
                        maxToMinUI.Add(item.Value);
                    &#125;
                &#125;
                if (removeKey != null)
                &#123;
                    for (int i = 0; i &lt; removeKey.Count; i++)
                    &#123;
                        dicShowUI.Remove(removeKey[i]);
                    &#125;
                &#125;

                if (maxToMinUI.Count &gt; 0)
                &#123;
                    maxToMinUI.Sort(delegate (BaseUI a, BaseUI b) &#123; return a.CurrentDepth.CompareTo(b); &#125;);
                    for (int i = 0; i &lt; maxToMinUI.Count; i++)
                    &#123;
                        newList.Add(maxToMinUI[i].GetUiId);
                    &#125;
                    uiReturnInfor.willBeShowUI = baseUI;
                    uiReturnInfor.listReturn = newList;
                    stackReturnInfor.Push(uiReturnInfor);
                &#125;
            &#125;
        &#125;

        if (baseUI.uiType.showMode == EShowUIMode.NoReturn)
        &#123;
            HideAllUI(true);
        &#125;
    &#125;

    private void HideAllUI(bool isHideAboveUI)
    &#123;
        List&lt;EUiId&gt; listRemove = null;
        if (isHideAboveUI)
        &#123;
            foreach (KeyValuePair&lt;EUiId, BaseUI&gt; item in dicShowUI)
            &#123;
                item.Value.HideUI(null);
            &#125;
            dicShowUI.Clear();
        &#125;
        else
        &#123;
            foreach (KeyValuePair&lt;EUiId, BaseUI&gt; item in dicShowUI)
            &#123;
                if (item.Value.uiType.rootType == EUIRootType.KeepAbove)
                &#123;
                    continue;
                &#125;
                else
                &#123;
                    if (listRemove == null)
                    &#123;
                        listRemove = new List&lt;EUiId&gt;();
                        listRemove.Add(item.Key);
                        item.Value.HideUI(null);
                    &#125;
                &#125;
            &#125;
        &#125;
        if (listRemove != null)
        &#123;
            for (int i = 0; i &lt; listRemove.Count; i++)
            &#123;
                listRemove.Remove(listRemove[i]);
            &#125;
        &#125;
    &#125;

    private RectTransform GetTheRoot(BaseUI baseUI)
    &#123;
        if (baseUI.uiType.rootType == EUIRootType.Normal)
        &#123;
            return normalUIRoot;
        &#125;
        if (baseUI.uiType.rootType == EUIRootType.KeepAbove)
        &#123;
            return keepAboveUIRoot;
        &#125;
        else
        &#123;
            return uiRootTrans;
        &#125;
    &#125;

    public BaseUI GetBaseUI(EUiId uiId)
    &#123;
        if (dicAllUI.ContainsKey(uiId))
        &#123;
            return dicAllUI[uiId];
        &#125;
        else
        &#123;
            return null;
        &#125;
    &#125;
    public void HideUI(EUiId uiId, DelAfterHideUI del)
    &#123;
        HideTheUI(uiId, del);
    &#125;
    public void HideTheUI(EUiId uiId, DelAfterHideUI del)
    &#123;
        if (!dicShowUI.ContainsKey(uiId))
        &#123;
            return;
        &#125;
        if (del != null)
        &#123;
            del += delegate &#123; dicShowUI.Remove(uiId); &#125;;
            dicShowUI[uiId].HideUI(del);
        &#125;
        else
        &#123;
            dicShowUI[uiId].HideUI(null);
            dicShowUI.Remove(uiId);
        &#125;
    &#125;

    public void ClickReturn()
    &#123;
        if (stackReturnInfor.Count == 0)
        &#123;
            if (currentUI == null)
            &#123;
                return;
            &#125;
            EUiId beforeUiId = currentUI.GetBeforeuiId;
            if (beforeUiId != EUiId.NullUI)
            &#123;
                HideUI(currentUI.GetUiId, delegate &#123; ShowUI(beforeUiId); &#125;);
            &#125;
        &#125;
        else
        &#123;
            UIReturnInfor uiReturnInfor = stackReturnInfor.Peek();
            if (uiReturnInfor != null)
            &#123;
                EUiId theId = uiReturnInfor.willBeShowUI.GetUiId;
                if (dicShowUI.ContainsKey(theId))
                &#123;
                    HideUI(theId, delegate
                    &#123;
                        if (!dicShowUI.ContainsKey(uiReturnInfor.listReturn[0]))
                        &#123;
                            BaseUI baseUI = GetBaseUI(uiReturnInfor.listReturn[0]);
                            baseUI.ShowUI();
                            dicShowUI[baseUI.GetUiId] = baseUI;

                            this.beforeUI = currentUI;
                            this.currentUI = baseUI;
                            stackReturnInfor.Pop();
                        &#125;
                    &#125;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="LoginUI"><a href="#LoginUI" class="headerlink" title="LoginUI"></a>LoginUI</h3><pre><code>public class LoginUI : BaseUI &#123;

    private InputField userNameInputField;//用户名输入框
    private InputField passWordInputField;//密码输入框
    private Button startButton;//开始游戏按钮
    public override void InitUIOnAwake()
    &#123;
        userNameInputField = GameTool.FindTheChild(this.gameObject, &quot;Field Username/InputField&quot;).GetComponent&lt;InputField&gt;();
        passWordInputField = GameTool.FindTheChild(this.gameObject, &quot;Field Password/InputField&quot;).GetComponent&lt;InputField&gt;();
        startButton = GameTool.FindTheChild(this.gameObject, &quot;Log In Button&quot;).GetComponent&lt;Button&gt;();

        startButton.onClick.AddListener(delegate () &#123; OnStartClick(); &#125;);
        InitUIData();
    &#125;

    public override void InitUIData()
    &#123;
        base.InitUIData();
        this.uiId = EUiId.LoginUI;
        this.uiType.rootType = EUIRootType.Normal;
        this.uiType.isResetReturnUIInfor = true;
    &#125;

    private void OnStartClick()
    &#123;
        UIManager.instance.ShowUI(EUiId.MainUI);
    &#125;

&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前 UI 框架就做到这里了，大部分功能都可以实现。下一步要做的就是把主要的 UI 面板做出来可以实现界面之间的跳转。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>井字棋小游戏</title>
    <url>/2018/07/02/Unity/Tic_Tac_Toe/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正在看《C#6.0本质论》为了更清楚的了解书中的内容，特地花了一天的时间通过在 Unity 中实现这个游戏来总结一下 1~3 章的内容。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文这要的思路是通过位操作来实现，记录两个玩家每一步的位置。当然算法不止一种，主要是基于《C#6.0本质论》里讲到的内容做一个总结</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>通过位操作（position = 1 &lt;&lt; position ）来获取当前玩家选中的位置</p>
</li>
<li><p>positionX(or positionO) |= position 来记录该玩家所有选中的位置</p>
</li>
<li><p>根据所有的可能性来判断是否成功 （target &amp; positionX(or positionO) == target) (target 为目标位置 如：111 000 000、 000 111 000 、 000 000 111 …)</p>
<h2 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h2></li>
<li><p>位置选择  </p>
<pre><code>  public void OnButtonClick()
  &#123;
      if (isSelect)
      &#123;
          GameView.instance.ShowTips(&quot;已被选...&quot;);
          return;
      &#125;

      isSelect = true;//标记此位置已被选中

      GameManager.instance.SetPostion(playerPos);//记录选中位置

      //贴图
      image.material = GameView.instance.GetMaterial(GameManager.instance.player);

      //判断游戏是否结束
      if (GameManager.instance.GameOver(playerPos))
      &#123;
          GameView.instance.ShowTipsAllTimes(&quot;游戏结束\n恭喜 &quot; + GameManager.instance.player.ToString() +&quot; 获胜！！！&quot;);
          return;
      &#125;

      //更换玩家
      GameManager.instance.player = (GameManager.instance.player == Player.O)
          ? GameManager.instance.player = Player.X
          : Player.O;

      GameView.instance.SetPlayer(GameManager.instance.player);
  &#125;
</code></pre>
</li>
<li><p>记录玩家已选择的位置</p>
<pre><code>  private int postionX; //记录 X 玩家已选择的位置
  private int postionO; //记录 O 玩家已选择的位置
  public void SetPostion( int _position)
  &#123;
      //每次玩家选择的位置
      int position = 1 &lt;&lt; _position;

      //判断是哪个玩家选择了该位置
      if (player == Player.O)
      &#123;
          //通过 |= 操作来记录玩家所有选择的位置 （0 为未选择 ， 1 位已选择）
          postionO |= position;
      &#125;
      else
      &#123;
          postionX |= position;
      &#125;
  &#125;
</code></pre>
</li>
<li><p>判断游戏结束  </p>
<pre><code>  //成功的所有可能性
  int[] winningMasks = &#123;7, 56 , 448 , 73 , 146 , 292 , 84 , 273&#125;
  public bool GameOver(int _playerPos)
  &#123;
      foreach (int mask in winningMasks)
      &#123;
          if ((mask &amp; postionX) == mask)// X 玩家获胜
          &#123;
              isOver = true;
              break;
          &#125;
          else if ((mask &amp; postionO) == mask)// O 玩家获胜
          &#123;
              isOver = true;
              break;
          &#125;
      &#125;
      //平局
      if (!GameView.instance.items.Any(item =&gt; item.IsSelect == false))
      &#123;
          isOver = false;
          GameView.instance.ShowTipsAllTimes(&quot;平局&quot;);
      &#125;

      return isOver;
  &#125;
</code></pre>
</li>
</ul>
<p>其实通过位操作实现起来还蛮简单的，当然这只是简单的 3*3 的图。 后面如果有时间的话我会加上 AI 自动下棋功能。可能会用到数据结构中的图。正好我也在学习书籍结构…</p>
<h2 id="工程及源代码"><a href="#工程及源代码" class="headerlink" title="工程及源代码"></a>工程及源代码</h2><p><a href="https://github.com/Lenzan/Tic_Tac_Toe">Project</a></p>
<h2 id="配图"><a href="#配图" class="headerlink" title="配图"></a>配图</h2><p><img src="/img/tic_tac_toe/3.jpg" alt="图片"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>井字棋</tag>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D 项目专属文件夹</title>
    <url>/2018/08/15/Unity/UnityFolder/</url>
    <content><![CDATA[<h2 id="Unity3D-项目专属文件夹须知"><a href="#Unity3D-项目专属文件夹须知" class="headerlink" title="Unity3D 项目专属文件夹须知"></a>Unity3D 项目专属文件夹须知</h2><h3 id="隐藏文件夹"><a href="#隐藏文件夹" class="headerlink" title="隐藏文件夹"></a>隐藏文件夹</h3><p>以.开头的文件夹会被Unity忽略。在这种文件夹中的资源不会被导入，脚本不会被编译。也不会出现在Project视图中。这种文件我们可以在资源浏览器的时候，能找到这些文件。</p>
<h3 id="standard-Assets"><a href="#standard-Assets" class="headerlink" title="standard Assets"></a>standard Assets</h3><p>在这个文件夹中的脚本最先被编译。一般是放一些Unity 内置的一些资源。<br>这个文件夹中的脚本会被导出到Assembly-CSharp-firstpass,Assembly-UnityScript-firstpass 或 Assembly-Boo-firstpass项目中，依语言而定。<br><a href="http://docs.unity3d.com/Documentation/Manual/ScriptCompileOrderFolders.html">官方文档</a><br>在这个文件夹中的脚本比其他脚本都要先编译。将脚本放在这个文件夹里，就可以用C#脚本来访问js脚本或其他语言的脚本。</p>
<h3 id="Pro-Standard-Assets"><a href="#Pro-Standard-Assets" class="headerlink" title="Pro Standard Assets"></a>Pro Standard Assets</h3><p>和StandardAssets相同，只不过里面的文件是给Pro版本的Unity使用的。当然它的功能更为的丰富，例如一些高级内置的shader文件，只有在Pro版才能起作用。</p>
<h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><p>以Editor命名的文件夹允许其中的脚本访问UnityEditor的API。如果脚本中使用了在UnityEditor命名空间中的类或方法，它必须被放在名为Editor的文件夹中。Editor文件夹中的脚本不会在build时被包含。<br>在项目中可以有多个Editor文件夹。［注意：如果在普通的文件夹下，Editor文件夹可以处于目录的任何层级。如果在特殊文件夹下，那Editor文件夹必须是特殊文件夹的直接子目录。］</p>
<h3 id="Editor-Default-Resources"><a href="#Editor-Default-Resources" class="headerlink" title="Editor Default Resources"></a>Editor Default Resources</h3><p>你可以把编辑器用到的一些资源放在这里，比如图片、文本文件、等等。它和Editor文件夹一样都不会被打到最终发布包里，仅仅用于开发时使用。你可以直接通过EditorGUIUtility.Load去读取该文件夹下的资源，<br>例如：</p>
<pre><code>TextAsset text =    EditorGUIUtility.Load(“1.txt&quot;) as TextAsset;
</code></pre>
<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>Plugins文件夹用来放native插件。它们会被自动包含进build中去。注意这个文件夹只能是Assets文件夹的直接子目录。<br>例如：<br>Windows：dll文件:<br>Mac OS X：bundle文件；<br>Linux下：.so文件。<br>和StandardAssets一样，这里的脚本会更早的编译，并且允许它们被之外的脚本访问。   </p>
<ul>
<li>Plugins/x86 || x86_64   (一般PC平台)<br>如果为32bit或64bit平台创建游戏，那么这个文件夹下的nativeplugin文件会被自动的包含在游戏build中。如果这个文件夹不存在，则Unity会查找Plugins文件夹下的nativepluglins。<br>如果要创建universalbuild，建议你同时使用这两个文件夹。然后将32bit和64bit的nativeplugins放进相应的文件夹中。</li>
<li>Plugins/Android<br>在这个文件夹里放入Java.jar文件。用于java语言的plugins。.so文件也会被包含进来。<br><a href="http://docs.unity3d.com/Documentation/Manual/PluginsForAndroid.html">官方文档</a></li>
<li>Plugins/iOS<br>在这个文件夹放入.o、.m 、 .mm 、.c 、.cpp等文件，一般在IOS 平台导出对应的文件。<br><a href="http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html">官方文档</a></li>
</ul>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>Resources 文件夹允许你在脚本中通过文件路径和名称来访问资源。放在这一文件夹的资源永远被包含进 build 中，即使它没有被使用。因为Unity无法判断脚本有没有访问了其中的资源。项目中可以有多个Resources文件夹，因此不建议在多个文件夹中放同名的资源。一旦build游戏，Resources 文件夹中的所有资源被打包进游戏存放资源的 archive 中。这样在游戏的 build 中就不存在 Resources 文件夹了。即使脚本中仍然使用了资源在项目中的路径。<a href="http://docs.unity3d.com/Documentation/Manual/LoadingResourcesatRuntime.html">官方文档</a><br>注意：<br>当资源作为脚本变量被访问时，这些资源在脚本被实例化后就被加载进内存。如果资源太大，你可能不希望它被这样加载。那么你可以将这些大资源放进 Resources 文件夹中，通过 Resources.Load 来加载。当不再使用这些资源了，可以通过 Destroy 物体，再调用 Resources.UnloadUnusedAssets 来释放内存。<br>特点：<br>    - 文件夹内资源打包集成 .asset 文件里面，例如一些 shader／material/prefab 等资源文件;<br>    - 里面的资源只能是只读，不能动态修改，一般动态的更新的资源不雅放在这个文件夹内;<br>    - 通过主线程加载；<br>    - Resources.Load(); 加载资源<br>         Resources.LoadAll(); 加载所有资源<br>         Resources.LoadAsync(); 异步加载资源</p>
<h3 id="Gizmos"><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h3><p>Gizmos 文件夹存放用 Gizmos.DrawIcon 方法使用的贴图、图标资源。放在 Gizmos 文件夹中的贴图资源可以直接通过名称使用，可以被 Editor 作为 gizmo 画在屏幕上。这里还是要说说 OnDrawGizmos() 方法，只要脚本继承了 MonoBehaviour 后，并且在编辑模式下就会每一帧都执行它。发布的游戏肯定就不会执行了，它只能用于在 scene 视图中绘制一些小物件。比如要做摄像机轨迹，那么肯定是要在 Scene 视图中做一个预览的线，那么用 Gizmos.DrawLine 和 Gizmos.DrawFrustum 就再好不过了。</p>
<h3 id="WebPlayerTemplates"><a href="#WebPlayerTemplates" class="headerlink" title="WebPlayerTemplates"></a>WebPlayerTemplates</h3><p>用来替换 webbuild 的默认网页。这个文件夹中的脚本都不会被编译。这个文件夹必须作为 Assets 文件夹的直接子目录。</p>
<h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>这里的文件会被拷贝到 build 文件夹中，不会修改（移动和网页版不同，他们会被嵌入到最终 build 文件中）。它们的路径会因平台而有差异，但都可以通过 Application.streamingAssetsPath 来访问。<br>例如：有些游戏为了让所有的资源全部使用 assetbundle ，会把一些初始的 assetbundle 放在 StreamingAssets 目录下, StreamingAssets 目录下的资源都是不压缩的，而且它比较大会占空间。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D 动态生成二维码</title>
    <url>/2018/05/06/Unity/buildCode2D/</url>
    <content><![CDATA[<a id="more"></a>
<p>前一段时间开发项目中需要用到二维码识别登录，项目做完之后没来得及整理 所有现在先整理一下希望对你们有所帮助</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>需要下载个工具 –  <a href="http://pan.baidu.com/s/1nvsogUt">链接</a> 密码：80bg<br>将下载下来的文件放到你的Unity工程里面 （整理好的）</p>
<h2 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h2><p>using UnityEngine;<br>using ZXing;<br>using ZXing.QrCode;<br>using System.IO;<br>using System.Collections.Generic;</p>
<pre><code>namespace Tools.Code2D
&#123;
    public class BuildCode2D : Singleton&lt;BuildCode2D&gt;
    &#123;
        public Sprite CreateSpriteCode2D(string code_2d_message)
        &#123;
            Texture2D code_2d = CreateTextureCode2D(code_2d_message);
            return Sprite.Create(code_2d, new Rect(0, 0, code_2d.width, code_2d.height), Vector2.zero);
        &#125;
        public Texture2D CreateTextureCode2D(string code_2d_message)
        &#123;
            Texture2D code_2d = new Texture2D(256, 256);
            if (code_2d_message != null)
            &#123;
                var color32 = Encode(code_2d_message, code_2d.width, code_2d.height);
                code_2d.SetPixels32(color32);
                code_2d.Apply();
                byte[] bytes = code_2d.EncodeToPNG();//把二维码转成byte数组，然后进行输出保存为png图片就可以保存下来生成好的二维码  
                if (!Directory.Exists(Application.dataPath + &quot;/Code2D&quot;))//创建生成目录，如果不存在则创建目录  
                &#123;
                    Directory.CreateDirectory(Application.dataPath + &quot;/Code2D&quot;);
                &#125;
                string fileName = Application.dataPath + &quot;/Code2D/&quot; + code_2d_message + &quot;.png&quot;;
                File.WriteAllBytes(fileName, bytes);
            &#125;
            return code_2d;
        &#125;
        private static Color32[] Encode(string textForEncoding, int width, int height)
        &#123;
            Dictionary&lt;EncodeHintType, object&gt; hints = new Dictionary&lt;EncodeHintType, object&gt;();
            hints.Add(EncodeHintType.CHARACTER_SET, &quot;UTF-8&quot;);
            var writer = new BarcodeWriter
            &#123;
                Format = BarcodeFormat.QR_CODE,
                Options = new QrCodeEncodingOptions
                &#123;
                    Height = height,
                    Width = width,
                &#125;,
                Encoder = new QRCodeWriter
                &#123;

                &#125;
            &#125;;
            var bitMatrix = writer.Encoder.encode(textForEncoding, BarcodeFormat.QR_CODE, width, height, hints);
            return writer.Write(bitMatrix);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="创建脚本CreateCode2D"><a href="#创建脚本CreateCode2D" class="headerlink" title="创建脚本CreateCode2D"></a>创建脚本CreateCode2D</h2><pre><code>using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using Tools.Code2D;
using System;

public class CreateCode2D : MonoBehaviour &#123;
    public Image image;
    //创建二维码
    public Sprite CreateSpriteCode()
    &#123;
       return  BuildCode2D.Instance.CreateSpriteCode2D(GetTimeStamp());
    &#125;

    public Texture2D CreatTexture2DCode()
    &#123;
        return BuildCode2D.Instance.CreateTextureCode2D(GetTimeStamp());
    &#125;
    //获取当前的时间戳
    public string GetTimeStamp()
    &#123;
        TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);
        string result = ts.TotalSeconds.ToString();
        return result;
    &#125;

    //点击生成二维码的按钮
    public void ButtonClick()
    &#123;
        image.sprite = CreateSpriteCode();
    &#125;
&#125;
</code></pre>
<p>此脚本只是用来生成二维码（根据当前的时间戳） 因为时间原因就先写到这里了，后面会将二维码的识别功能也加上。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 AssetBundle 的常见问题</title>
    <url>/2018/06/03/assetbundle/Troubleshooting/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本节描述在使用 assetbundle 的项目中经常出现的几个问题。</p>
<h2 id="资源重复（Asset-Duplication）"><a href="#资源重复（Asset-Duplication）" class="headerlink" title="资源重复（Asset Duplication）"></a>资源重复（Asset Duplication）</h2><p>Unity 5的 AssetBundle 系统将在 object 被构建成 AssetBundle 时查找 object 的所有依赖项。这是基于资源数据库完成的。这种依赖信息用于确定将被包含在 AssetBundle 中的 Objects 。<br>被指定分配给 AssetBundle 的 Object 只会被构建到该 AssetBundle 中（ Object 的 assetBundleName 不为空）。<br>任何在 AssetBundle 中没有指定分配的 Object 都将包含在所有引用了该 Object 的 AssetBundle 中，无论 AssetBundle 中有一个还是多个 Objects 引用了它。<br>如果两个不同的对象被分配给两个不同的 assetbundle ，但是它们都有一个共同依赖对象的引用，那么这个依赖对象将被复制到两个 assetbundle中。重复的依赖也会被实例化，这意味着依赖对象的两个副本将被视为具有不同标识符的不同对象。这将增加应用程序的 assetbundle 的大小。如果应用加载了这两个 AssetBundles ，那么就会导致内存中加载了两份Object。<br>有几种方法可以解决这个问题：</p>
<ol>
<li>确定打包进不同的 assetbundle 中的 Object 没有相同的依赖。任何共享依赖项的对象都可以被放置到同一个 AssetBundle 中，避免重复依赖。</li>
</ol>
<ul>
<li> 这种方法对于具有很多共享依赖的项目来说是不可行的。并且造成使整个 assetbundle 频繁的重新构建和下载。不方便，不高效。</li>
</ul>
<ol start="2">
<li>分割 AssetBundles，使得拥有共同依赖的 AssetBundles 不会同时被加载。</li>
</ol>
<ul>
<li>这种方法可能适用于某些类型的项目，比如以关卡为基础的游戏。然而，它仍然不必要地增加了项目的 assetbundle 的大小，并且增加了构建时间和加载时间</li>
</ul>
<ol start="3">
<li>确保所有依赖项资产都被构建到自己的 assetbundle 中。这完全消除了重复资产的风险，但也带来了复杂性。应用程序必须跟踪 AssetBundle 之间的依赖关系，并确保在调用任何 AssetBundle 之前加载得当的 AssetBundle 。</li>
</ol>
<p>在 Unity 5 中，对象依赖关系通过位于 UnityEditor 名称空间中的 AssetDatabase API 来跟踪。正如名称空间那样，这个 API 只在 Unity 编辑器中可用，而不是在运行时。AssetDatabase.GetDependencies 可以用来定位特定对象或资产的所有直接依赖项。注意这些依赖项可能有它们自己的依赖关系。此外，还可以使用 AssetImporter API 来查询分配给任何特定对象的 AssetBundle 。<br>通过组合 AssetDatabase 和 AssetImporter apis ，可以编写一个编辑器脚本，以确保 AssetBundle 的所有直接或间接依赖被分配给各自的AssetBundle ，或者任意两个有共享依赖的 AssetBundles ,被打包进一个 assetbundle ，由于复制资源的内存成本，建议所有项目都有这样的脚本。</p>
<h2 id="Sprite-图集重复（Sprite-Atlas-Duplication）"><a href="#Sprite-图集重复（Sprite-Atlas-Duplication）" class="headerlink" title="Sprite 图集重复（Sprite Atlas Duplication）"></a>Sprite 图集重复（Sprite Atlas Duplication）</h2><p>当 Unity5 中资源依赖的计算代码，和自动生成 Sprite Atlas 结合使用的时候，会出一点奇怪的问题，<br>任何自动生成的 sprite 图集都会和图集生成的 Sprite Objects 一起打包到 AssetBundle 中。如果 Sprite Objects 被分配给多个 AssetBundles，那么 Sprite Atlas 就不会被打包为一个 AssetBundle ，并且出现资源重复。如果精 sprite object 没有被分配给一个AssetBundle ，那么 Sprite atlas 也不会被分配给一个 AssetBundle。<br>为了确保 Sprite Atlas 没有被复制.需要检查划分到同一个 Sprite Atlas 的 sprites (Tag 相同)要被指明为相同的 AssetBundle。</p>
<h2 id="安卓纹理问题（Android-Textures）"><a href="#安卓纹理问题（Android-Textures）" class="headerlink" title="安卓纹理问题（Android Textures）"></a>安卓纹理问题（Android Textures）</h2><p>由于 Android 生态系统中设备的严重碎片化，通常需要将纹理压缩成几种不同的格式。虽然所有的 Android 设备都支持 ETC1，但是 ETC1 不支持带有 alpha 通道的纹理。如果一个应用程序不需要 OpenGL ES 2 支持，解决这个问题的最干净的方法是使用 ETC2 ，它由所有 Android OpenGL ES 3 设备支持。<br>大多数应用程序需要在没有 ETC2 支持的旧设备上运行。解决这个问题的一种方法是使用 Unity 5 的 AssetBundle 版本变量。（请参阅 Unity 的 Android 优化指南，了解其他选项的详细信息。）<br>要使用 AssetBundle 版本变量，所有不能用 ETC1 格式压缩的纹理必须被到只包含纹理的 assetbundle 中。接下来，接着，为不支持 ETC2 格式的安卓生态系统创建合适的版本变量，使用特定的纹理压缩格式，比如：DXT5、PVRTC、ATITC。针对每一个版本变量，改变纹理的 TextureImporter 设置，使其与版本变量一致。<br>在运行时，使用 SystemInfo.SupportsTextureFormat() 方法可以检测支持的纹理压缩格式。你可以使用这个信息，根据所支持的格式纹理，选择和加载相应的 AssetBundle 版本变量。</p>
<h2 id="IOS文件句柄溢出（iOS-File-Handle-Overuse）"><a href="#IOS文件句柄溢出（iOS-File-Handle-Overuse）" class="headerlink" title="IOS文件句柄溢出（iOS File Handle Overuse）"></a>IOS文件句柄溢出（iOS File Handle Overuse）</h2><p>当前版本已经解决这个问题 具体不在描述</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 AssetBundle 的依赖关系</title>
    <url>/2018/05/16/assetbundle/assetbundle%20Dependencies/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="AssetBundle的依赖关系"><a href="#AssetBundle的依赖关系" class="headerlink" title="AssetBundle的依赖关系"></a>AssetBundle的依赖关系</h3><p>在一个 assetbundle 中有一个或多个 UnityEngine.Objects 引用了其他 assetbundle 中的 UnityEngine.Object, 那么这两个 assetbundle 之间就产生了依赖关系。如果 UnityEngine.ObjectA 对象在任何 assetbundle 中都不包含对 UnityEngine.ObjectA 的引用，则不会产生依赖。<br>在这种情况下，（指的是前面两个例子的后者，既不产生依赖的情况），被依赖对象（ UnityEngine.ObjectB ）将被拷贝进你创建的      AssetBundle（指包含 UnityEngine.ObjectA 的 AssetBundle ）。如果多个 assetbundle 中的多个 UnityEngine.Object 包含对同一个对象的引用，那么每一个对该对象有依赖关系的 bundle 都将创建自己的对象副本，并将其打包到 AssetBundle 中。<br>如果一个 assetbundle 包有依赖性，很重要的一点是，那些包含了被依赖对象的 AssetBundles，需要在你想要实例化的对象的加载之前加载。Unity 不会自动帮你加载这些依赖。<br>下面有个例子，assetbundle 1 中的一个 materail 引用了 assetbundle 2 中的一个 Texture:<br>在加载 ssetbundle 1 中的 aterail 之前需要先将 assetbundle 2 中的 Texture 加载到内存。按照什么样的顺序加载 assetbundle1 和  assetbundle2 不重要，想从 Bundle1 中加载材质前，你需要先加载 Bundle2。<br>在下一节中，我们将讨论如何使用我们在上一节中提到的 AssetBundleManifest，在运行时确定并加载依赖。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 AssetBundle 管理器</title>
    <url>/2018/05/30/assetbundle/assetbundle%20manager/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="AssetBundle-管理器"><a href="#AssetBundle-管理器" class="headerlink" title="AssetBundle 管理器"></a>AssetBundle 管理器</h2><p>AssetBundle 管理器可以在 Asset Store 里面下载，它是一个由 Unity 制作的工具，可以使使用 AssetBundle 更加流线化。下载和导入AssetBundle Manager 包不仅增加了加载和使用AssetBundle的新API调用，而且还添加了一些编辑器功能来简化工作流程。这个功能可以在 Assets 菜单选项下找到。<br>这个新部分将包含以下选项：</p>
<h3 id="模拟模式（Simulation-Mode）"><a href="#模拟模式（Simulation-Mode）" class="headerlink" title="模拟模式（Simulation Mode）"></a>模拟模式（Simulation Mode）</h3><p>启用模拟模式允许 AssetBundle 管理器使用 AssetBundle，但不需要实际构建 bundle 包本身。编辑器将查看哪些资产被分配给 AssetBundle，并直接使用资产，而不是将它们从 AssetBundle 中提取出来。<br>使用模拟模式的主要优点是，可以修改、更新、添加和删除资产，而不需要每次都重新构建和部署 assetbundle。<br>值得注意的是，AssetBundle 变量不能与模拟模式一起工作。如果您需要使用变量，则本地 AssetBundle 服务器是您需要的选项。</p>
<h3 id="本地assetbundle服务器（Local-AssetBundle-Server）"><a href="#本地assetbundle服务器（Local-AssetBundle-Server）" class="headerlink" title="本地assetbundle服务器（Local AssetBundle Server）"></a>本地assetbundle服务器（Local AssetBundle Server）</h3><p>AssetBundle管理器还可以启动一个本地 AssetBundle 服务器，它可以用来在编辑器或本地构建（包括移动）中测试 AssetBundle 。<br>让本地 AssetBundle 服务器工作的规定是，您必须在项目的根目录中创建一个名为 AssetBundle 的文件夹，该文件夹与资产文件夹的级别相同。如:<br>![avatar](/images/assetbundle/Local AssetBundle Server.png)<br>创建文件夹之后，需要将 assetbundle 构建到这个文件夹中。要做到这一点，请从新的菜单选项中选择 Build assetbundle。这将把它们构建到那个目录中。<br>现在您已经构建了 assetbundle （或者已经决定使用模拟模式），并准备开始加载 assetbundle 。让我们看一下通过 AssetBundle Manager 提供给我们的新的 API 调用。</p>
<h4 id="AssetBundleManage-r初始化-AssetBundleManager-Initialize"><a href="#AssetBundleManage-r初始化-AssetBundleManager-Initialize" class="headerlink" title="AssetBundleManage r初始化( AssetBundleManager.Initialize() )"></a>AssetBundleManage r初始化( AssetBundleManager.Initialize() )</h4><p>这个函数加载 AssetBundleManifest 对象，在开始使用 AssetBundle Manager 加载资产之前，您需要调用它。在一个非常简单的例子中，初始化 AssetBundle 管理器可以是这样的：</p>
<pre><code>IEnumerator Start()
&#123;
    yield return StartCoroutine(Initialize());
&#125;
IEnumerator Initialize()
&#123;
    var request = AssetBundleManager.Initialize();
    if (request != null)
        yield return StartCoroutine(request);
&#125;
</code></pre>
<p>AssetBundle 管理器在使用 Initialize（） 期间加载的 manifest 来帮助幕后的许多特性，包括依赖项管理。</p>
<h4 id="加载资源（Loading-Assets）"><a href="#加载资源（Loading-Assets）" class="headerlink" title="加载资源（Loading Assets）"></a>加载资源（Loading Assets）</h4><p>你使用的是 AssetBundle 管理器，你已经初始化它，现在你已经准备好加载一些资产了。让我们看一下如何加载 AssetBundle 并从该包中实例化一个对象：</p>
<pre><code>IEnumerator InstantiateGameObjectAsync (string assetBundleName, string assetName)
&#123;
    // Load asset from assetBundle.
    AssetBundleLoadAssetOperation request = AssetBundleManager.LoadAssetAsync(assetBundleName, assetName, typeof(GameObject) );
    if (request == null)
        yield break;
    yield return StartCoroutine(request);
    // Get the asset.
    GameObject prefab = request.GetAsset&lt;GameObject&gt; ();
    if (prefab != null)
        GameObject.Instantiate(prefab);
&#125;
</code></pre>
<p>AssetBundle 管理器异步加载，并返回一个加载请求，它在调用 yield return StartCoroutine（request） 时加载 bundle ;从那里我们需要做的就是调用 GetAsset（） 来从 AssetBundle 加载一个游戏对象。</p>
<h4 id="加载场景（Loading-Scenes）"><a href="#加载场景（Loading-Scenes）" class="headerlink" title="加载场景（Loading Scenes）"></a>加载场景（Loading Scenes）</h4><p>如果你的 assetbundle 中是一个场景，那么你的带有会有稍微的不同。下面是如何从一个 AssetBundle 中加载一个场景：</p>
<pre><code>IEnumerator InitializeLevelAsync (string levelName, bool isAdditive)
&#123;
    // Load level from assetBundle.
    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(sceneAssetBundle, levelName, isAdditive);
    if (request == null)
        yield break;
    yield return StartCoroutine(request);
&#125;
</code></pre>
<p>如您所见，加载场景也是异步的，LoadLevelAsync 返回一个加载请求，它需要被传递到 StartCoroutine，以便加载场景。</p>
<h4 id="加载版本变量（Load-Variants）"><a href="#加载版本变量（Load-Variants）" class="headerlink" title="加载版本变量（Load Variants）"></a>加载版本变量（Load Variants）</h4><p>使用 AssetBundle Manager 加载版本变量实际上与加载场景和资源没有什么不同。只需要设置 AssetBundleManager 的 ActiveVariant 属性。<br>activevariant 属性是字符串数组。简单地构建一系列字符串，其中包含您在分配给资产时创建的版本变量的名称。下面是如何加载带有版本变量的场景 AssetBundle 。</p>
<pre><code>IEnumerator InitializeLevelAsync (string levelName, bool isAdditive, string[] variants)
&#123;
    //Set the activeVariants.
    AssetBundleManager.ActiveVariants = variants;
    // Load level from assetBundle.
    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(variantSceneAssetBundle, levelName, isAdditive);
    if (request == null)
        yield break;
    yield return StartCoroutine(request);
&#125;
</code></pre>
<p>在你的的代码的其他地方传入字符串数组。如果版本变量是有效的，这段代码将加载和版本变量一致的 AssetBundles 。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 assetbundle 工作流程</title>
    <url>/2018/05/20/assetbundle/assetbundle%20workflow/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇是主要是关于 assetbundle 从创建到加载再到使用的整个工作流程</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="AssetBundle-工作流"><a href="#AssetBundle-工作流" class="headerlink" title="AssetBundle 工作流"></a>AssetBundle 工作流</h3><p>根据下面的步骤开始学习使用 assetbundle ，更多的其他的详细流程可以在该文档的其他文章中找到</p>
<h3 id="将资源配置到-AssetBundle"><a href="#将资源配置到-AssetBundle" class="headerlink" title="将资源配置到 AssetBundle"></a>将资源配置到 AssetBundle</h3><p>按照以下步骤 将资源分配给特定的 AssetBundle </p>
<ol>
<li>从 Project 面板里面选择一个你想要分配到 assetbundle 的资源</li>
<li>检查 Inspector 面板</li>
<li>在 Inspector 面板底部，你可以看到可以设置assetbundle 和变量的区域</li>
<li>左侧的下拉菜单可以设置 assetbundle 右侧的下拉菜单设置变量</li>
<li>左侧下拉菜单默认显示 “None” ,点击左侧的下拉菜单，可以看到已经注册过的 assetbundle 的名称选项</li>
<li>点击 “ New… “来创建一个新的 Assetbundle 名称</li>
<li>输入你需要 assetbundle 的名称。注意 : AssetBundle 的名称是支持目录结构的，这取决于你输入的名字 如果想要添加子文件夹只需用“/”分割即可（比如：textfile/text1 , textfile/text2 ）</li>
<li>一旦你选择或者创建一个 assetbundle 名称时，接着你就可以在右侧的下拉菜单中重复上述的步骤选择或者创建一个变量名称，变量名称对于AssetBundle 不是必须的<br>想要看更多关于 AssetBundle 配置和配置策略相关的内容 ，请看[为 AssetBundle 打包准备资产]一节<h3 id="创建AssetBundles"><a href="#创建AssetBundles" class="headerlink" title="创建AssetBundles"></a>创建AssetBundles</h3>在 Assets 目录下创建一个 Editor 文件夹，然后创建一个包含以下代码的代码文件放到 Editor 文件夹下<pre><code> using UnityEditor;
 public class CreateAssetBundles
 &#123;
     [MenuItem(&quot;Assets/Build AssetBundles&quot;)]
     static void BuildAllAssetBundles()
     &#123;
         string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;
         if(!Directory.Exists(assetBundleDirectory))
         &#123;
             Directory.CreateDirectory(assetBundleDirectory);
         &#125;
         BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);
     &#125;
 &#125;
</code></pre>
这个脚本将会在 “Assets” 菜单的最底部，创建一个叫 “Build AssetBundles” 的按钮。当你点击该按钮，就会执行脚本中与之对应的方法。接着，所有被你命名了的资远都会被构建成对应的 AssetBundle ，并放置在你定义的路径下。在本章节中，该路径为：”Assets/AssetBundles”。<h3 id="将AssetBundle上传到远程仓库"><a href="#将AssetBundle上传到远程仓库" class="headerlink" title="将AssetBundle上传到远程仓库"></a>将AssetBundle上传到远程仓库</h3>这一步对于每个开发者来说都是不同的而不是 Unity 告诉你该如何做。如果你计划将 AssetBundle 部署到远程虚拟主机上，则需要继续学习相关的内容，如果你只是本地开发，并且将 AssetBundle 存储到本地磁盘中，你可以跳过本节内容。<h3 id="加载AssetBundle和资产（assets）"><a href="#加载AssetBundle和资产（assets）" class="headerlink" title="加载AssetBundle和资产（assets）"></a>加载AssetBundle和资产（assets）</h3>对于想要本地开发的用户来说，你可能对 “AssetBundles.LoadFromFile” 这个API感兴趣 下面是代码：<pre><code> public class LoadFromFileExample : MonoBehaviour &#123;
     void Start() &#123;
         var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
         if (myLoadedAssetBundle == null) &#123;
             Debug.Log(&quot;Failed to load AssetBundle!&quot;);
             return;
         &#125;
         var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);
         Instantiate(prefab);
     &#125;
 &#125;
</code></pre>
LoadFromFile（path） path = assetbundle 存储的路径<br>如果你的 AssetBundle 存放在远程主机上，你需要下载到你的游戏中，你可能会用到 “UnityWebRequest” 这个 API 。下面是例子代码<pre><code> IEnumerator InstantiateObject()&#123;
     string url = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName;  
     UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(url, 0);
     yield return request.Send();
     AssetBundle bundle = DownLoadHandlerAssetBundle.GetContent(request);
     GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
     GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
     Instantiate(cube);
     Instantiate(sprite);
 &#125;
</code></pre>
GetAssetBundle(url , int)<br>url = 你想下载的 assetbundle 的地址<br>int = 你想下载的 assetbundle 的版本<br>在这个例子中 url 指向的是本地路径，但是 url 可以指向任何一个你拥有的 AssetBundle 的地址<br>UnityWebRequest 里面有个处理 AssetBundle 的方法 DownloadHandlerAssetBundle 这个方法可以从网络中请求中获取到 assetbundle<br>不管你使用什么样的方法，你现在可以获取到一个 AssetBundle 对象了从这个对象中你可以使用带有泛型T 的方法 LoasAssets&lt; T &gt;(string)string参数为存储在包里面的你要加载的对象的名字，这样就会 return 一个从 AssetBundle 中你正在加载的 Object ，你可以用这个方法在Unity 中加载任何一个对象。比如：你想在场景中创建一个 GameObject ,你只需要调用 Instantiate(gameObjectFromAssetBundle).<br>想要了解更多关于加载 AssetBundles 的 APIs 的信息，可以看[使用本地 AssetBundle ]一节。<h2 id="zansimples有话说"><a href="#zansimples有话说" class="headerlink" title="zansimples有话说"></a>zansimples有话说</h2>没话说，想要知道更多关于 Unity 有关的知识，可以关注一下我的博客，谢谢</li>
</ol>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D AssetBundle 框架整理（二）</title>
    <url>/2018/07/30/assetbundle/assetbundle-manager/</url>
    <content><![CDATA[<h3 id="资源加载业务接口创建"><a href="#资源加载业务接口创建" class="headerlink" title="资源加载业务接口创建"></a>资源加载业务接口创建</h3><a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们的自动做标记已经完成，这样 Unity 就可以通过调用 BuildPipeline.BuildAssetBundles() 这个 API 自动根据资源的 assetbundleName 属性批量打包，并且自动建立依赖关系。<br>后面的部分就开始真正的开始开发如何将打进包内的资源准确的加载出来。</p>
<h3 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h3><p>首先我们先把资源加载的接口创建出来，方便需要此功能的对象继承并实现。</p>
<p>  public interface IAssetLoader<br>  {<br>    Object LoadAsset(string assetName) ;<br>    Object[] LoadAllAssets();<br>    Object[] LoadAssetWithSubAssets(string assetName);<br>    void UnLoadAsset(Object asset);<br>    void Dispose();<br>    GetAllAssetNames();//调试专用<br>  }</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 assetbundle</title>
    <url>/2018/05/16/assetbundle/assetbundle/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想要自己做个游戏，其中要研究一下 assetbundle 的机制 所以先记录一下关于这方面的学习笔记，Unity 版本已经更新到2018.1.0了，根据新版本的官方文档深入学习一下</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="AssetBundles"><a href="#AssetBundles" class="headerlink" title="AssetBundles"></a>AssetBundles</h3><p>AssetBundle 是一个在运行时加载的一个归档文件，其中包含了特定平台的资源 （ models,Textures,prefabs,audio clips,scenes ）assetbundles 相互之间可以相互依赖 比如：assetbundle A 中的一个 material 可以引用 assetbundle B中的一个 texture。<br>为了能够在网络上快速传递，assetbundle 可以根据自己的需求选择内置的压缩算法进行压缩（LZMA 算法 和 LZ4 算法）<br>assetbundle 可以用于可下载的内容更新（DLC），减少初始包体大小，为终端用户的平台加载优化的资源，并减少运行时内存压力。</p>
<h3 id="什么是AssetBundle"><a href="#什么是AssetBundle" class="headerlink" title="什么是AssetBundle?"></a>什么是AssetBundle?</h3><p>事实上 “AssetBundle” 涉及到两个不同但相关的事情<br>首先是磁盘上存储的实际文件 我们称这种文件为 “AssetBundle 归档” ，存档可以被认为是一个容器，就像一个文件夹，它包含了里面的附加文件。这些额外的文件由两种类型组成：序列化文件和资源文件<br>序列化文件：将你的资源组合形成各个对象，并将这些对象写入到一个文件中，这个文件就是序列化文件<br>资源文件：就是为某些资源（比如 texture,audio ）单独存储的二进制数据块，方便我们有效的从另一个线程上加载它们<br>其次，assetbundle 是一个你可以从特定的归档中用代码 Load 你想要的资源的一个对象。这个对象包含了一组映射，即：&lt;添加到归档中所有资源的文件路径，资源相对应的对象&gt;，你可以根据这种映射关系，在需要的时候加载你想要的资源对象</p>
<h1 id="zansimples有话说"><a href="#zansimples有话说" class="headerlink" title="zansimples有话说"></a>zansimples有话说</h1><p>我是根据官方文档配上有道词典翻一下来的，有什么不对的地方可以随便戳我。我只是想说英语水平不达标，看英文文档那是相当的难啊！！！！</p>
<p>希望本篇文章对你们有所帮助</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 创建 assetbundle</title>
    <url>/2018/05/24/assetbundle/building%20assetbundles/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 assetbundle 工作流一篇中我们知道了一个带有三个参数的的方法这里让我们深入的去了解一下这个方法。<br>BuildPipeline.BuildAssetBundles(string outpath , BuildAssetBundleOptions.None,BuildTarget.Standalone)，<br>Assets/AssetBundles 这是 assetbundle 将要被打包进的路径（outpath） 这个路径可以在你的磁盘里随意设置，只要确定 assetbundle 打包的时候这个路径存在就 OK 了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h3><p>你可以指定不同的内置的 BuildAssetBundleOptions ，它们有各自的效果。有关这个 eunm 其他的选项 你可以参阅关于BuildAssetBundleOptions 的脚本API参考资料<br>你可以根据项目的需要，选择不同的选项，这里介绍三个涉及到 assetbundle 压缩方式的选项</p>
<ol>
<li><p>BuildAssetBundleOptions.None：这个选项是 AssetBundle 用 LZMA 的格式进行压缩，它会把序列化数据文件压缩成一个单独的 LZMA 流。LZMA 算法会在使用之前将整个包全部解压缩，这就导致了，即使你是用了很小的一个文件，仍然需要很长的加载时间。值得注意的是，用这个选项时，当你用包中的任何资源的时候，就必须将整个 assetbundle 包解压缩。<br>一旦解压缩之后，它将再次用 LZ4 算法压缩并且存入磁盘中。但是这个算法在你是用的时候不需要将整个包解压缩。这种算法最好使用在一个assetbundle 包含了很多资源，当我们获取了其中一个资源的时候其他的资源也将会被陆续加载。比如：一个角色或者一个场景的所有资源。<br>LZMA 算法只推荐使用在从远程服务器下载的小文件作为初始化用。一旦下载下来，它将缓存为 LZ4 算法压缩的 assetbundle 文件</p>
</li>
<li><p>BuildAssetBundleOptions.UncompressedAssetBundle：这个选项是在你打包 assetbundle 的时候完全不压缩，这就导致了文件包体太大下载时间变长，但是一旦下载下来，加载的速度会很快。</p>
</li>
<li><p>BuildAssetBundleOptions. ChunkBasedCompression：这个选项是用LZ4算法压缩，这样会使 Assetbundle 比用 LZMA 算法压缩的包体更大，但是使用其中的资源的时候不会将整个包解压缩。LZ4 是一种基于数据块的算法，这个算法在将 assetbundle 加载成单个的数据块，当一个数据块被解压后，其中包含的资源就可以使用，即使这个 assetbundle 中其他的数据块还没有被解压。<br>使用这个方法压缩的 assetbundle 包与未压缩的 assetbundle 包有差不多的加载时间，但是降低了磁盘的占用空间。</p>
<h3 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h3><p>BuildTarget.Standalone: 这个参数是用来告诉流水线将要使用那个平台进行打包，你可以在 BuildTarget 这个 API 上找到所有的选项。当然，如果你不想硬编码 BuildTarget ,你也可以使用 EditorUserBuildSettings.activeBuildTarget ，它可以根据你当前的编译平台自动找到对应的平台来创建 Assetbundle 。</p>
</li>
</ol>
<p>脚本写好之后，你就可以创建 Assetbundle 了。点击 Assets/Build AssetsBundles 来创建。</p>
<p>现在你已经成功的创建了 AssetBundles 了。你可以注意到你的 assetbundle 文件里面多于你创建的 assetbundle 文件。确切来说应该是2*（n+1）个多于出来的文件，让我们花点时间来复习一下 BuildPipeline.BuildAssetBundles 这个方法</p>
<p>在编辑器中你可以看到你每个指定的 assetbundle 文件，你都会看到有个跟它同名的 “.manifest” 文件<br>另外还有一个额外的 bundle ，并且 manifest 文件的名字没有和任何一个你创建的 assetbundle 包重名，实际上，他是以所在的文件夹来命名，这就是 Assetbundle Bundle 。我们将会讨论更多关于它的内容并且在将来怎么使用它们。</p>
<h3 id="The-AssetBundle文件"><a href="#The-AssetBundle文件" class="headerlink" title="The AssetBundle文件"></a>The AssetBundle文件</h3><p>这个 file 是指没有带 “.manifest” 并且在运行的时候加载的并用其中的资源的文件。<br>Assetbundle 文件是内部包含了多个文件的归档文件。这个归档文件的结构可以根据它是一个普通的 assetbundle 还是一个场景的 assetbundle 有稍微的变化。下面是一个普通 assetbundle 的内部结构图<br><img src="/img/assetbundle/assetbundle.png" alt="avatar"><br>场景 assetbundle 不同于普通 assetbundle 的是，场景的加载数据流和他说包含的内容都有所优化</p>
<h3 id="The-Manifest文件"><a href="#The-Manifest文件" class="headerlink" title="The Manifest文件"></a>The Manifest文件</h3><p>对于每个生成的 assetbundle ，包括额外生成的 manifest Bundle ,都会随之生成一个 “.manifest” 文件。这个文件可以用任何编辑器打开，里面包含了一些 assetbundle 相关的信息，比如循环冗余检查（CRC）以及其他的依赖数据。普通的 assetbundle 的 manifest 文件是这样的</p>
<pre><code>    ManifestFileVersion: 0
    CRC: 2422268106
    Hashes:
    AssetFileHash:
        serializedVersion: 2
        Hash: 8b6db55a2344f068cf8a9be0a662ba15
    TypeTreeHash:
        serializedVersion: 2
        Hash: 37ad974993dbaa77485dd2a0c38f347a
    HashAppended: 0
    ClassTypes:
    - Class: 91
    Script: &#123;instanceID: 0&#125;
    Assets:
    Asset_0: Assets/Mecanim/StateMachine.controller
    Dependencies: &#123;&#125;
</code></pre>
<p>Manifest Bundle 的 manifest 文件是这样的</p>
<pre><code>    ManifestFileVersion: 0
    AssetBundleManifest:
    AssetBundleInfos:
        Info_0:
        Name: scene1assetbundle
        Dependencies: &#123;&#125;
</code></pre>
<p>显示了 assetbundle 是如何关联的以及他们的依赖是什么。<br>现在只需要理解这个包中包含了 AssetBundleManifest 对象，对运行的时候加载那个依赖的 assetbundle 非常有用<br>要了解更多关于如何使用这个 bundle 和 manifest 对象的信息,请参阅关于使用 assetbundle 的文档。</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之 AssetBundle 补丁更新</title>
    <url>/2018/06/01/assetbundle/patching%20with%20AssetBundles/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="AssetBundle-补丁更新"><a href="#AssetBundle-补丁更新" class="headerlink" title="AssetBundle 补丁更新"></a>AssetBundle 补丁更新</h2><p>修复 AssetBundle 就像下载一个新的 AssetBundle 并替换现有的 AssetBundle 一样简单。如果 WWW.LoadFromCacheOrDownload 或UnityWebRequest 用于管理应用程序的缓存 assetbundle ，将一个不同的版本参数传递给所选的 API 将会下载新的 assetbundle 。<br>在修补系统中要解决的更困难的问题是检测要替换的assetbundle。一个修补系统需要两个信息列表：</p>
<ol>
<li>当前下载的 assetbundle 的列表，以及它们的版本控制信息</li>
<li>服务器上的 assetbundle 和它们的版本信息的列表<br>修复者应该下载服务器端 AssetBundle 的列表，并比较 AssetBundle 列表。丢失的 assetbundle ，或其版本化信息已经更改的 assetbundle ，应该重新下载。还可以编写一个定制系统来检测 assetbundle 的变化。大多数编写自己系统的开发人员选择为他们的 AssetBundle 文件列表使用行业标准的数据格式，比如 JSON ，以及用于计算校验和的标准 C#，比如 MD5 。<br>Unity 以一种确定的方式构建了 assetbundle 。这允许使用自定义下载器的应用程序实现微分补丁。<br>Unity 没有为差异化更新提供任何内置的机制，无论是 WWW.LoadFromCacheOrDownload ，还是 UnityWebRequest ，在使用内置的缓存系统的时候，都不能实现差异化更新。如果想要实现差异化更新，需要自己编写一个定制下载器。</li>
</ol>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之准备 assetbundle 资源</title>
    <url>/2018/05/22/assetbundle/preparing%20assets%20for%20assetbundle/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你可以将任何资源分配给任何你想要的 AssetBundle,这是你的自由。但是当你打包的时候这里有一些策略你可以考虑一下，你可以从下面的这些分组策略中找到一种或多种去使用在你自己的项目中。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h3><p>逻辑实体分组策略是：当你分配 AssetBundle 资产的时候，这些资产在项目中代表了某部分的功能（这些包括UI界面，角色，游戏环境还有任何一个在生命周期中频繁调用的部分）<br>example :</p>
<ol>
<li>把UI界面上的布局信息和所有的纹理打包到一起</li>
<li>把角色的模型和动画信息打包到一起</li>
<li>把需要在多个场景中共享的模型或者纹理打包到一起</li>
</ol>
<p>逻辑实体分组对于可下载内容（DLC）是个理想的解决方案，这样就可以将所有的东西分隔开，当你对单个实体进行更改的时候，就不需要下载额外的，不变的资产了<br>想要正确的使用这个方案，开发人员想要将资产分配给各自的 AssetBundle 包，那就必须要求开发人员对整个项目的每一个使用到资产的地方都要很清楚的知道。</p>
<h3 id="类型分组"><a href="#类型分组" class="headerlink" title="类型分组"></a>类型分组</h3><p>类型分组就是将类型相似的资产打包到一起，比如：音频文件和语言本地化文件<br>类型分组对于跨平台开发是个较好的策略，比如：你的音频的压缩方式在 Windows 和 mac 平台之间是相同的,那么你就可以将所有的音频文件打包进一个 AssetBundle 中，并且可以重复使用。相反的在 mac 上压缩好的一个 shader 文件，在 Windows 上是不可以用的。<br>除此之外，如果你的纹理压缩格式，代码，预设等资产没有那么频繁的改动的话，那这个策略可以使你的 AssetBundle 可以兼容多个 Unity 版本</p>
<h3 id="并行分组"><a href="#并行分组" class="headerlink" title="并行分组"></a>并行分组</h3><p>并行分组就是讲那些需要同时使用和加载的资产打包到一起，你可能会想到游戏中的一个关卡中包含了该关卡独有的角色，纹理，音频等，这个策略就是将这些东西打包到一起。你必须确定在 assetbundle 中的某个资产，只能和这个 assetbundle 中的其他资产一起使用。在并行分组策略中对于单体的依赖会加载的时间明显增加，因为这会强制加载被依赖的那个文件所在的整个 assetbundle 包。比如：assetbundle A 依赖于assetBundle B 中的某个资产 ，那么在你加载 Assetbundle A 的同时 assetBundle B 也会被强制加载这样就会需要更多的加载时间。<br>并行开发最常见的例子就是打包整个场景的资产。在这个策略中一个场景包中应该包含大部分或者全部场景的依赖。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>请注意：一个项目中肯定可以根据你的需要混合使用这些策略，根据项目的需要使用最优化的资产打包策略，这样大大提高了项目的开发效率。<br>比如：项目中将UI界面在不同的平台上打包到不同的 assetbundle 中，而不是场景或者关卡中有交互的内容打包到一起</p>
<p>不管你用什么样的策略，这里有一些额外的小建议：</p>
<ol>
<li>将频繁调用的和那些计划不调用的资产打进不同的包中</li>
<li>将可能会同时加载的资源（model，materials，textures，animations）打进一个包中</li>
<li>如果一个 assetbundle 中的某些资源对另一个 assetbundle 有依赖，并且其他的 assetbundle 也对这个 assetbundle 有依赖的话，那么可以将那些被依赖的资源提取出来打进一个 assetbundle 中作为共享资产来使用</li>
<li>如果两组对象不可能同时加载，比如标准画质和高清画质，确保它们在自己的 assetbundle 包中</li>
<li>如果超过50%的 bundle 在同一时间被频繁加载的话，你可以考虑将他们分割出来</li>
<li>如果有较少的资产（5到10个）需要经常同时加载，你可以考虑将它们打包到一起</li>
<li>如果一组对象只是同一对象的不同版本，则考虑使用 assetbundle 中的变量</li>
</ol>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity官方文档翻译之使用本地 assetbundles</title>
    <url>/2018/05/28/assetbundle/using%20assetbundles%20natively/</url>
    <content><![CDATA[<h3 id="使用本地-assetbundles"><a href="#使用本地-assetbundles" class="headerlink" title="使用本地 assetbundles"></a>使用本地 assetbundles</h3><p>在 Unity5 中，有四种不同的方式来加载 assetbundles ,他们的方法是根据被加载的平台来使用不同的压缩方法（未压缩，LZMA , LZ4 ）创建assetbundle ，<br>我们要处理的四个 APIs 是：</p>
<ul>
<li>AssetBundle.LoadFromMemoryAsync</li>
<li>AssetBundle.LoadFromFile</li>
<li><a href="WWW.LoadfromCacheOrDownload">WWW.LoadfromCacheOrDownload</a></li>
<li>UnityWebRequest’s DownloadHandlerAssetBundle ( Unity 5.3 or 更新版本)</li>
</ul>
<h4 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h4><p>这个函数的参数是含有 assetbundle 数据的字节数组，如果你愿意的话，你也可以选择传入一个 CRC 值,如果 assetbundle 包是用 lzma 算法压缩的，当它加载时会被解压缩。如果是用 LZ4 算法压缩的 assetbundle 包，那么直接加载压缩状态的包。<br>这有个如何使用这个方法的例子：</p>
<pre><code>using UnityEngine;
using System.Collections;
using System.IO;

public class Example : MonoBehaviour
&#123;
    IEnumerator LoadFromMemoryAsync(string path)
    &#123;
        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
        yield return createRequest;
        AssetBundle bundle = createRequest.assetBundle;
        var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    &#125;
&#125;
</code></pre>
<p>然而，这并不是使用 LoadFromMemoryAsync 的唯一策略，File.ReadAllBytes（path）可以用任何想要获得字节数组的过程来替换</p>
<h4 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h4><p>这个 API 在本地加载未压缩的 bundles 的时候非常的高效。LoadFromFile 这个方法会直接从磁盘中加载，如果这个包是未压缩或者用 LZ4 算法压缩的 bundles。用这个方法加载一个用 LZMA 压缩的 bundles ,在加载到内存之前，先要将其解压缩。<br>一个如何使用 LoadFromFile 的例子：</p>
<pre><code>public class LoadFromFileExample extends MonoBehaviour &#123;
    void Start() &#123;
        var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        if (myLoadedAssetBundle == null) &#123;
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        &#125;
        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    &#125;
&#125;
</code></pre>
<p>注意：在安卓设备上，用 unity5.3 或者更早版本使用这个 api 在从 Streaming Assets 路径下加载 bundles 时会报错，因为这条路径的内容将驻留在压缩的 .jar 文件中。在 Unity5.4 及会更高版本可以很好的使用这个方法。</p>
<h4 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a><a href="WWW.LoadFromCacheOrDownload">WWW.LoadFromCacheOrDownload</a></h4><p><strong>这个API已经被启用（你可以使用UnityWebRequest）</strong><br>这个 API 对于从远程服务器下载 assetbundle 或加载本地的 assetbundle 非常有用。它是 UnityWebRequest API 的旧版本，不太理想的版本。从远程服务器加载一个 AssetBundle 将自动缓存 AssetBundle 。如果 AssetBundle 被压缩，一个线程将被启动，解压缩并且将其写入缓存。一旦 bundle 被解压和缓存，它就会像 AssetBundle.LoadFromFile 一样载入。<br>如何使用 LoadFromCacheOrDownload 的一个例子：</p>
<pre><code>using UnityEngine;
using System.Collections;
public class LoadFromCacheOrDownloadExample : MonoBehaviour
&#123;
    IEnumerator Start ()
    &#123;
        while (!Caching.ready)
                yield return null;

        var www = WWW.LoadFromCacheOrDownload(&quot;http://myserver.com/myassetBundle&quot;, 5);
        yield return www;
        if(!string.IsNullOrEmpty(www.error))
        &#123;
            Debug.Log(www.error);
            yield return;
        &#125;
        var myLoadedAssetBundle = www.assetBundle;

        var asset = myLoadedAssetBundle.mainAsset;
    &#125;
&#125;
</code></pre>
<p>由于考虑到在 WWW 对象中缓存 AssetBundle 的字节的内存开销，建议所有使用 WWW 的开发人员。LoadFromCacheOrDownload 确保他们的assetbundle 很小——最多只有几兆字节。还建议在有限内存平台上运行的开发人员，比如移动设备，确保他们的代码每次只下载一个 AssetBundle ，以避免内存峰值。如果缓存文件夹没有任何空间来缓存额外的文件，那么 LoadFromCacheOrDownload 将会从缓存中迭代地删除最近使用的AssetBundle ，直到有足够的空间来储存新的 AssetBundle 。如果空间不可能使用（因为硬盘已经满了，或者缓存中的所有文件都在使用中），LoadFromCacheOrDownload（） 将绕过缓存，将文件传输到内存中。<br>为了强制 LoadFromCacheOrDownload 的下载版本参数（第二个参数）需要被改变。如果传递给函数的版本与当前缓存的 AssetBundle 的版本相匹配，那么 AssetBundle 只会从缓存中加载。</p>
<h4 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h4><p>UnityWebRequest 有一个专门的 API 调用来处理 assetbundle 。首先，您需要使用 UnityWebRequest.GetAssetBundle() 来创建您的 web 请求。返回请求后，将请求对象传递到 DownloadHandlerAssetBundle.GetContent（UnityWebRequest）。这个 GetContent 调用会返回你的AssetBundle 对象。<br>下载完成之后，还可以在 DownloadHandlerAssetBundle 类上使用 assetBundle 属性，这就和使用 AssetBundle.LoadFromFile 加载assetbundle 是一样的。<br>下面是一个如何加载包含两个 gameobject 并实例化它们的 AssetBundle 的示例。要开始这个过程，我们只需要调用 StartCoroutine（InstantiateObject()）;</p>
<pre><code>IEnumerator InstantiateObject()
&#123;
    string uri = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName;       
    UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
&#125;
</code></pre>
<p>使用 UnityWebRequest 的优势在于，它允许开发者以更灵活的方式处理下载的数据，并可能消除不必要的内存使用。这个比 UnityEngine.WWW 更超前，更推荐使用。</p>
<h5 id="Loading-Assets-from-AssetBundles"><a href="#Loading-Assets-from-AssetBundles" class="headerlink" title="Loading Assets from AssetBundles"></a>Loading Assets from AssetBundles</h5><p>现在您已经成功地下载了您的 AssetBundle ，现在是时候加载一些资产了。<br>通用代码片段:</p>
<pre><code>T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);
</code></pre>
<p>T是你想要加载的资产类型。<br>在决定如何加载资产时，有几个选项我们有 LoadAsset、LoadAllAsset 和它们的 Async 对等物，分别是 LoadAssetAsync 和LoadAllAssetsAsync 。<br>这就是如何同步地从 assetbundle 中加载资产：<br>加载一个单独的游戏对象：</p>
<pre><code>GameObject gameObject = loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);
</code></pre>
<p>加载所有的游戏对象：</p>
<pre><code>Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();
</code></pre>
<p>现在，当先前显示的方法返回您正在加载的对象的类型或对象数组时，异步方法返回一个 AssetBundleRequest ，在访问资产之前，您需要等待这个操作完成。加载一个资产:</p>
<pre><code>AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);
yield return request;
var loadedAsset = request.asset;
</code></pre>
<p>和</p>
<pre><code>AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();
yield return request;
var loadedAssets = request.allAssets;
</code></pre>
<p>一旦你把你的资产加载了，你可以像在 Unity 中使用任何对象一样使用加载的对象。</p>
<h5 id="Loading-AssetBundle-Manifests"><a href="#Loading-AssetBundle-Manifests" class="headerlink" title="Loading AssetBundle Manifests"></a>Loading AssetBundle Manifests</h5><p>加载AssetBundle清单可能非常有用。特别是在处理 AssetBundle 依赖项时。要获得一个可用的 AssetBundleManifest 对象，您需要加载额外的AssetBundle （它的名称与它所在的文件夹相同），并从中加载一个 AssetBundleManifest 的对象。<br>从 AssetBundle 中加载 manifest 完全和从中加载其他资源一样：</p>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
</code></pre>
<p>现在您可以通过上面例子中的 manifest 对象访问 AssetBundleManifest API 调用。在这里，您可以使用 manifest 来获得关于您构建的assetbundle 的信息。这些信息包括依赖数据、hash 数据和 assetbundle 的变量数据。<br>请记住在前面的部分中，当我们讨论 AssetBundle 依赖关系时，如果一个 bundles 对另一个 bundles 有依赖关系，那么这些 bundle 在加载原始bundles中的任何资产之前都需要加载。Manifest 可以找到可能的加载依赖项。比方说，我们想要加载名为 “AssetBundle” 的 assetBundle 的所有依赖项。</p>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); //Pass the name of the bundle you want the dependencies for.
foreach(string dependency in dependencies)
&#123;
    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));
&#125;
</code></pre>
<p>现在您已经加载了 AssetBundle、AssetBundle 的依赖，现在是讨论管理所有这些加载的 AssetBundle 的时候了。</p>
<h4 id="Managing-Loaded-AssetBundles"><a href="#Managing-Loaded-AssetBundles" class="headerlink" title="Managing Loaded AssetBundles"></a>Managing Loaded AssetBundles</h4><p>当从活动场景中删除对象时，Unity 不会自动卸载对象。资产清理是在特定的时间触发的，它也可以手动触发。<br>重要的是要知道何时加载和卸载 AssetBundle 。不恰当地卸载一个 AssetBundle 会导致重复对象错误，或者其他不可预知的错误，比如缺少纹理。<br>关于 AssetBundle 管理的最重要的事情是什么时候调用 AssetBundle.Unload(bool) ; 。如果你要把 true 或 false 传递给函数调用.Unload 是一个非静态的方法，它将卸载你的 AssetBundle 。这个 API 卸载被调用的 AssetBundle 的头信息。该参数表明是否也卸载从这个AssetBundle 中实例化的所有对象。AssetBundle.Unload(true) 卸载从 AssetBundle 中加载的所有 GameObjects （及其依赖项）。这不包括复制的 GameObjects （比如实例化的 gameobject ），因为它们不再属于 AssetBundle 。当这种情况发生时，从 AssetBundle 中加载的纹理（仍然属于它）从场景中的 gameobject 中消失，Unity 将它们视为缺失的纹理。<br>让我们假设材质M是从 AssetBundle AB 加载的，如下所示。</p>
<ol>
<li>如果调用 AB.Unload(true) 。在活动场景中任何M的实例也将被卸载和销毁。</li>
<li>如果调用 ab.Unload（false） ，它将打破当前 M 和 AB 的联系。<br><img src="/img/assetbundle/unloadfalse.png" alt="avatar"><br>如果 AB 再次被加载，并且 AB.LoadAsset（）被调用， Unity 不会将已经存在的使用 Material M 的实例与 AssetBundle AB 重新联系。因此将存在两份被加载的 Material M。<br><img src="/img/assetbundle/after.jpg" alt="avatar"><br>通常，使用 assetbundle.Unload（false） 不会得到理想的情况。大多数项目都应该使用 assetbundle.Unload（true） 来避免在内存中复制对象。<br>大多数项目都应该使用 assetbundle.Unload（true） 并采用一种方法来确保对象不会被复制，两个常见的方法是:</li>
<li>在应用程序的生命周期中选择一个好的时机来卸载 AssetBundle ,比如关卡之间，或者加载场景的时候。</li>
<li>为每个对象采取引用计数管理方法，只有当 AssetBundle 的所有对象都没有被使用的时候，再卸载 AssetBundle。这样就可以避免应用出现重复对象的问题。<br>如果应用程序必须使用 assetbundle.Unload（false） ，那么单个对象只能以两种方式卸载：</li>
<li>在场景和代码中消除对不需要的对象的所有引用，然后调用 Resources.UnloadUnusedAssets();</li>
<li>加载一个没有额外附加的场景，这将消除当前场景的所有对象，并自动调用 Resources.UnloadUnusedAssets。<br>如果您不想自己管理加载 AssetBundle、依赖关系，以及资源，您可能会发现自己需要 AssetBundle 管理器。</li>
</ol>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之数据结构绪论</title>
    <url>/2018/06/16/data/data%20structure-1/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>我们说到数据结构，首先应该知道什么是数据。</p>
<p>数据：是描述客观事物的符号，是计算机可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</p>
<h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>
<p>例：人类中的数据元素是 ：人</p>
<p>畜类中的数据元素：牛、马、羊 …</p>
<h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>数据项：一个数据元素可以由若干个数据项组成。</p>
<p>例如：人这个数据元素,可以有 眼、耳、鼻等，也可以有姓名、年龄等数据项，需要什么数据项根据具体情况定。</p>
<p>数据项是数据不可分割的最小单位。</p>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象：是性质相同的数据元素的集合，是诗句的子集。</p>
<p>性质相同就是说数据元素有相同数量和类型的数据项，比如，人都有姓名，年龄等相同的数据项。</p>
<p>在我们的实际应用中，处理的数据元素通常都是具有相同性质，在不产生混淆的情况下，我们都将数据对象简称为数据。</p>
<p>所以知道了以上几种概念之后我们的数据结构就可以很好的理解了。</p>
<p>所谓的结构，简单的理解就是关系，比如说分子结构，是由原子之间的排列方式。不同的数据元素之间不是独立的，而是存在着特定的关系，我们将这些关系成为结构。</p>
<h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><p>根据视点的不同，我们把数据结构分为逻辑结构和物理结构</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构：是指数据对象中数据元素之间的相互关系。逻辑结构分为以下四种：</p>
<h3 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h3><p>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他的关系。<br><img src="/img/data/list.jpg" alt="avatar"></p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性结构：线性结构中的数据元素之间是一对一的关系。<br><img src="/img/data/liner.jpg" alt="avatar"></p>
<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>树形结构：树形结构中的数据元素之间存在一对多的层次关系。<br><img src="/img/data/tree.jpg" alt="avatar"></p>
<h3 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h3><p>图形结构：图形结构的数据元素是多对多的关系。<br><img src="/img/data/picture.jpg" alt="avatar"></p>
<p>物理结构：是指数据的逻辑结构在计算机中的存储形式。</p>
<p>数据的存储结构应正确的反映数据元素之间的逻辑关系，这是关键，</p>
<p>数据元素的存储方式有两种：顺序存储和链式存储。</p>
<p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。<br><img src="/img/data/phy.jpg" alt="avatar"></p>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br><img src="/img/data/last.jpg" alt="avatar"></p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。</p>
<p>抽象是指抽取事物具有的普遍性的本质。</p>
<p>抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。</p>
<p>抽象数据类型体现了程序设计中问题的分解，抽象和信息隐藏的特性。</p>
<p>现在已经开始学习数据结构了，其中肯定会遇到很多难题，但是无论学什么都需要努力才可以学到真的东西，只要掌握真技术的人，才可以去享用它。</p>
<h2 id="zansimples有话说"><a href="#zansimples有话说" class="headerlink" title="zansimples有话说"></a>zansimples有话说</h2><p>在本系列的一些文章当中，我会使用 C++ 作为展示例子的语言。<br>由于我的水平也不高，所有撰写文章时难免有疏漏，还望细心的朋友及时提出指正，在此我提前感谢大家。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D AssetBundle 框架整理（一）自动做标记</title>
    <url>/2018/07/18/assetbundle%20manager/auto%20setLable/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前也做了一些关于 AssetBundle 的了解，专门在官方网站上查了文档，现在我们开始着手造一个自己的轮子了，对就是 AssetBundle 框架，首先我们要做的是将想要打包的资源做上标记。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>就是提高开发效率，不用手动一个一个自己做标记，如果文件少的话还好，要是很多的话手动打标记不知道要打到什么时候。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实可想而知，自动打标记无非就是给我一个资源路径，我通过这个路径将里面的所有的资源文件遍历一遍，然后通过 AssetImporter 这个 API 设置每个文件的 assetbundleName 和 assetBundleVariant 属性，当然在设置属性的时候提前分好类，决定将哪些资源放到一个 AssetBundle 包内。然后记录一下要打多少个 AssetBundle 包，以及该包所在的目录，方便以后查找加载。</p>
<p>如果对文件操作不熟悉的百度一下，可以帮助理解。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code> # region 自动做标记
[MenuItem(&quot;AssetBundle/Set AssetBundle Lables&quot; ,false , 100)]
public static void SetAssetBundleLables()
&#123;
    //移除掉所有没有使用的标记
    AssetDatabase.RemoveUnusedAssetBundleNames();
    string assetDirectory = &quot;Assets/Res&quot;;
    DirectoryInfo directoryInfo = new DirectoryInfo(assetDirectory);
    DirectoryInfo[] scenesDirectories = directoryInfo.GetDirectories();
    foreach (var tempDir in scenesDirectories)
    &#123;
        string sceneDirectory = assetDirectory + &quot;/&quot; + tempDir.Name;
        DirectoryInfo sceneDirectoryInfo = new DirectoryInfo(sceneDirectory);
        if (sceneDirectoryInfo == null)
        &#123;
            Debug.Log(sceneDirectoryInfo + &quot;不存在&quot;);
            return;
        &#125;
        else
        &#123;
            Dictionary&lt;string , string&gt; namePathDictionary = new Dictionary&lt;string, string&gt;();
            int index = sceneDirectory.LastIndexOf(&quot;/&quot;);
            string sceneName = sceneDirectory.Substring(index + 1);
            OnSceneFileSystemInfo(sceneDirectoryInfo , sceneName , namePathDictionary);
            OnWriteConfig(sceneName , namePathDictionary);
        &#125;
    &#125;
    AssetDatabase.Refresh();
    Debug.Log(&quot;设置标记成功...&quot;);
&#125;

/// &lt;summary&gt;
/// 记录配置文件
/// &lt;/summary&gt;
/// &lt;param name=&quot;sceneDirectory&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;namePathDictionary&quot;&gt;&lt;/param&gt;
private static void OnWriteConfig(string sceneName , Dictionary&lt;string , string&gt; namePathDictionary)
&#123;
    string path = Application.dataPath + &quot;/AssetBundles/&quot; + sceneName ;
  
    if (!Directory.Exists(path)) Directory.CreateDirectory(path);
    Debug.Log(path);
    using (FileStream fs = new FileStream(path + &quot;/Record.txt&quot;, FileMode.OpenOrCreate , FileAccess.Write))
    &#123;
        using (StreamWriter sw = new StreamWriter(fs))
        &#123;
            sw.WriteLine(namePathDictionary.Count);
            foreach (KeyValuePair&lt;string , string&gt; kv in namePathDictionary)
            &#123;
                Debug.Log(kv.Value);
                sw.WriteLine(kv.Key+&quot;/&quot;+kv.Value);
            &#125;
        &#125;
    &#125;
&#125;

private static void OnSceneFileSystemInfo(FileSystemInfo fileSystemInfo , string sceneNama , Dictionary&lt;string, string&gt; namePathDictionary)
&#123;
    if (!fileSystemInfo.Exists)
    &#123;
        Debug.Log(fileSystemInfo + &quot;不存在&quot;);
        return;
    &#125;
    DirectoryInfo directoryInfo = fileSystemInfo as DirectoryInfo;

    FileSystemInfo[] fileSystemInfos = directoryInfo.GetFileSystemInfos();
    foreach (var systemInfo in fileSystemInfos)
    &#123;
        FileInfo fileInfo = systemInfo as FileInfo;
        if (fileInfo == null)
        &#123;
            OnSceneFileSystemInfo(systemInfo, sceneNama , namePathDictionary);
        &#125;
        else
        &#123;
            SetLables(fileInfo, sceneNama , namePathDictionary);
        &#125;
    &#125;
&#125;
/// &lt;summary&gt;
/// 修改资源 assetbundle lables
/// &lt;/summary&gt;
private static void SetLables(FileInfo fileInfo , string sceneName , Dictionary&lt;string, string&gt; namePathDictionary)
&#123;
    if(fileInfo.Extension == &quot;.meta&quot;)return;
    string bundleName = GetBundleName(fileInfo , sceneName);
    int index = fileInfo.FullName.IndexOf(&quot;Assets&quot;);
    string assetPath = fileInfo.FullName.Substring(index);
    AssetImporter assetImporter = AssetImporter.GetAtPath(assetPath);
    assetImporter.assetBundleName = bundleName;
    if (fileInfo.Extension == &quot;.unity&quot;)
        assetImporter.assetBundleVariant = &quot;u3d&quot;;
    else
        assetImporter.assetBundleVariant = &quot;assetbundle&quot;;
    string folderName;
    if (bundleName.Contains(&quot;/&quot;))
        folderName = bundleName.Split(&#39;/&#39;)[1];
    else
        folderName = bundleName;
    string bundlePath = assetImporter.assetBundleName + &quot;.&quot; + assetImporter.assetBundleVariant;
    if (!namePathDictionary.ContainsKey(folderName))
        namePathDictionary.Add(folderName, bundlePath);
&#125;

private static string GetBundleName(FileInfo fileInfo, string sceneName)
&#123;
    string path = fileInfo.FullName;
    int index = path.IndexOf(sceneName) + sceneName.Length;
    string bundlePath = path.Substring(index + 1);
    bundlePath = bundlePath.Replace(@&quot;\&quot;, &quot;/&quot;);
    if (bundlePath.Contains(&quot;/&quot;))
    &#123;
        string[] tmp = bundlePath.Split(&#39;/&#39;);
        
        return sceneName + &quot;/&quot; + tmp[0];
    &#125;
    return sceneName;
&#125;

#endregion
</code></pre>
<h3 id="一键打包"><a href="#一键打包" class="headerlink" title="一键打包"></a>一键打包</h3><p>根据刚才我们设置好的标记，Unity 就可以识别到我们想要打包的资源，官方有个打包 AssetBundle 的插件（ AssetBundle Browser ），你可以用那款插件打包。<br>我自己也写了一个但是不是很好，这个东西可以用官方的代替。也可以根据自己的需求改一下。我这里选择的压缩方式是不压缩（ BuildAssetBundleOptions.None 这个选项）。</p>
<pre><code>#region 打包
static void BuildAssetBundles(string outPath , BuildTarget target)
&#123;
    if (!Directory.Exists(outPath)) Directory.CreateDirectory(outPath);
    BuildPipeline.BuildAssetBundles(outPath, BuildAssetBundleOptions.None, target);
&#125;

[MenuItem(&quot;AssetBundle/CreateAndroidAssetBundles&quot;, false, 200)]
public static void BuildAndroidAssetBundles()
&#123;
    string outPath = &quot;Assets/AssetBundles/Android&quot;;
    BuildAssetBundles(outPath , BuildTarget.Android);
&#125;

[MenuItem(&quot;AssetBundle/CreateIOSAssetBundles&quot;, false, 201)]
public static void BuildIOSAssetBundles()
&#123;
    string outPath = &quot;Assets/AssetBundles/IOS&quot;;
    BuildAssetBundles(outPath, BuildTarget.iOS);
&#125;

[MenuItem(&quot;AssetBundle/CreateStandaloneWindows64AssetBundles&quot;, false, 202)]
public static void BuildStandaloneWindows64AssetBundles()
&#123;
    string outPath = &quot;Assets/AssetBundles/StandaloneWindows64&quot;;
    BuildAssetBundles(outPath, BuildTarget.StandaloneWindows64);
&#125;
#endregion
</code></pre>
<h3 id="一键删除"><a href="#一键删除" class="headerlink" title="一键删除"></a>一键删除</h3><p>这个就简单了，把目标路径删除掉就 OK 了。</p>
<pre><code>#region 一键删除
[MenuItem(&quot;AssetBundle/Delete All&quot;)]
static void DeletAssetBundles()
&#123;
    string outPuth = &quot;Assets/AssetBundles&quot;;
    Directory .Delete(outPuth , true);
    File.Delete(outPuth+ &quot;.meta&quot;);
    AssetDatabase.Refresh();
&#125;
#endregion
</code></pre>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之算法</title>
    <url>/2018/06/20/data/data%20structure-2/</url>
    <content><![CDATA[<h2 id="算法与算法描述"><a href="#算法与算法描述" class="headerlink" title="算法与算法描述"></a>算法与算法描述</h2><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><p>定义:算法是规则的有限集合，是为解决特定问题而规定的一系列操作。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性:"></a>特性:</h3><ul>
<li>有限性:有限步骤之内正常结束，不能形成无穷循环。</li>
<li>确定性: 算法中的每一个步骤必须有确定的含义，无二义。</li>
<li>输入: 有多个或0个输入。</li>
<li>输出: 至少有一个或多个输出。</li>
<li>可行性: 原则上能精确的进行操作通过已实现的基本运算执行有限次而完成。</li>
</ul>
<h3 id="设计的要求"><a href="#设计的要求" class="headerlink" title="设计的要求"></a>设计的要求</h3><ul>
<li>算法的正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效和低耗</li>
</ul>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>描述工具：自然语言，框图，高级语言。</li>
<li>程序：是算法在计算机上的实现<br>自然语言简单但有二义<br>框图易表达处理流程，难表达数据流程<br>高级语言准确但细节过多</li>
</ul>
<h4 id="类语言"><a href="#类语言" class="headerlink" title="类语言"></a>类语言</h4><p>类语言接近于高级语言而又不是严格的高级语言，具有高级语言的一般规格，撇掉语言中的细节。把注意力主要集中在算法处理步骤的本身上。</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>掌握算法的定义和特性</li>
<li>力争做出解决一类问题的优秀算法</li>
<li>算法描述用类语言，突出处理过程思路</li>
</ul>
<h2 id="算法性能评价"><a href="#算法性能评价" class="headerlink" title="算法性能评价"></a>算法性能评价</h2><p>标准：算法执行占用机器资源主要表现在执行时间和存储空间两个方面。<br>性能评价：算法效率与问题规模N有关，应是问题规模的函数。<br>问题规模N：反映问题大小的本质数且对于不同的问题其含义不同  </p>
<ul>
<li>对矩阵是阶数</li>
<li>对多项式运算是多项式项数</li>
<li>对图是定点个数</li>
<li>对集合运算是集合中的元素个数</li>
</ul>
<h3 id="有关数量关系的计算"><a href="#有关数量关系的计算" class="headerlink" title="有关数量关系的计算"></a>有关数量关系的计算</h3><p>数量关系评价可以提现在时间和空间上</p>
<h3 id="关于算法的执行时间"><a href="#关于算法的执行时间" class="headerlink" title="关于算法的执行时间"></a>关于算法的执行时间</h3><ul>
<li>算法执行时间 = 其所有语句执行时间的总和</li>
<li>语句执行时间 = 该条语句的执行次数 * 执行一次所需时间</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>算法实际执行时间与机器硬件和系统软件等多种因素有关，算法时间比较的本质是算法中语句执行次数的比较，相当于语句执行一次的时间均为 ‘1’ 不起作用。</p>
<h3 id="语句频度"><a href="#语句频度" class="headerlink" title="语句频度"></a>语句频度</h3><p>语句频度：是指该语句在一个算法中重复执行的次数  </p>
<pre><code>例：两个 n*n矩阵相乘
对应的语句频度                  算法语句            
  n          for(i=0;i&lt;n;i++)
  n^2           for(j=0;j&lt;n;j++)
                    &#123;
  n^2                  c[i][j] = 0;
  n^3                  for(k=0;k&lt;n;k++)
  n^3                       c[i][j] = c[i][j]+ a[i][k]*b[k][j];

                    &#125;
</code></pre>
<p>总执行次数 f(n) = 2n^3 + 2n^2 + n</p>
<h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>从语句频度刻画随问题规模 n 增加的函数 f(n) 执行时间量度。<br>记作 T(n) = O(f(n))<br>例：给出 x=x+1 的使劲按复杂度分析  </p>
<ol>
<li>x=x+1 ; 时间复杂度为O(1) ，称为常数阶。</li>
<li>for(i=1;i&lt;n;i++) x=x+1; 时间复杂度为O(n)， 称为线性阶。</li>
<li>for(i=1;i&lt;n;i++){for(j=1;j&lt;n;j++){x = x + 1;}} 时间复杂度为O(n^2)，称为平方阶。</li>
</ol>
<h3 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h3><p>定义：算法在最坏的情况下基本操作执行时间的上界。  </p>
<p>基本算法：是指算法中所研究问题的基本运算操作 </p>
<h4 id="例：顺序查找算法"><a href="#例：顺序查找算法" class="headerlink" title="例：顺序查找算法"></a>例：顺序查找算法</h4><pre><code>(1) i = n - 1  
(2) while(i&gt;0; &amp;&amp; (A[i] != k))  
(3)      i--;    
(4)      return i;   
</code></pre>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>例 A = [9 , 10 , 32 , 78 , 50]<br>查找成功：</p>
<ul>
<li>最坏的情况：A 中第一个元素为 K（例查找9）语句（3）的频度为 n 。</li>
<li>最好的情况：A 中最后一个元素为 K（例查找50）语句（3）的频度为 1 。</li>
</ul>
<p>查找失败<br>所有元素都找不到（例查找5）查找次数为 n+1 次。<br>算法最坏时间复杂度为 O(n) 。</p>
<h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>以存储单元个数刻画随问题规模增加的函数 f(n) ，存储空间量度记作：<br>S(n) = O(f(n))<br>空间复杂度原理同时间复杂度，具体内容不在详细介绍。</p>
<h2 id="总结与提高"><a href="#总结与提高" class="headerlink" title="总结与提高"></a>总结与提高</h2><ul>
<li>掌握数据的组织方式</li>
<li>掌握进行数据处理的基本技术</li>
<li>掌握算法设计分析的基本技能</li>
</ul>
<h3 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h3><p>包括数据的逻辑结构，存储结构，和运算集合三部分。</p>
<h4 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h4><ul>
<li>线性结构（1 : 1 , 线性表，栈，队列，字符串，数组，广义表等）</li>
<li>非线性结构（树 1：m , 图 m : n)</li>
</ul>
<h4 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h4><ul>
<li>顺序存储（一组连续的配置单元）</li>
<li>非顺序存储（一组任意配置单元）</li>
</ul>
<h4 id="定义其上的运算集合"><a href="#定义其上的运算集合" class="headerlink" title="定义其上的运算集合"></a>定义其上的运算集合</h4><p>掌握四类逻辑结构 ， 两类存储结构，掌握针对问题的数据组织方式。</p>
<h4 id="注意逻辑结构与存储结构的区别"><a href="#注意逻辑结构与存储结构的区别" class="headerlink" title="注意逻辑结构与存储结构的区别"></a>注意逻辑结构与存储结构的区别</h4><ul>
<li>逻辑结构定义了数据元素之间的逻辑关系</li>
<li>存储结构是逻辑结构在计算机中的实现。</li>
</ul>
<p>一种逻辑结构可以采用不同存储方式存放在计算机中，但必须反映出要求的逻辑关系。</p>
<h3 id="算法与算法分析"><a href="#算法与算法分析" class="headerlink" title="算法与算法分析"></a>算法与算法分析</h3><p>重点掌握算法的定义与特性,算法的正确性，算法的评价方法。
 </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之栈与队列-1</title>
    <url>/2018/06/24/data/stackandQueue/</url>
    <content><![CDATA[<h2 id="栈的定义与实现"><a href="#栈的定义与实现" class="headerlink" title="栈的定义与实现"></a>栈的定义与实现</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>定义：把运算位置限制在表尾端<br>栈顶：允许运算端<br>栈顶指示器：用来指示动态变化的栈顶位置<br>空栈：表中没有任何元素<br>满栈：无法申请到栈区可用空间<br>栈的常见运算：进栈或入栈（表尾插入）、出栈或退栈（表尾删除）<br>上溢：栈已满还要入栈<br>下溢：栈已空还要出栈<br>栈的特性：后进先出<br><img src="/img/stack/stack1.jpg" alt="stack"></p>
<h4 id="栈的抽象数据类型定义"><a href="#栈的抽象数据类型定义" class="headerlink" title="栈的抽象数据类型定义"></a>栈的抽象数据类型定义</h4><p>数据元素：可以是任意的数据，但必须属于同一数据对象。<br>关系：栈中数据元素之间是线性关系。<br>基本操作：</p>
<ul>
<li>InitStack(S)</li>
<li>ClearStack(S)</li>
<li>IsEmpty(S)</li>
<li>IsFull(S)</li>
<li>Push(S , x)</li>
<li>Pop(S , x)</li>
<li>GetTop(S , x)<h3 id="栈的顺序实现"><a href="#栈的顺序实现" class="headerlink" title="栈的顺序实现"></a>栈的顺序实现</h3>定义：</li>
<li>用一组连续的存储单元依次存放自栈底到栈顶的数据元素.</li>
<li>设一个位置指针top（栈顶指针）动态指示栈顶元素在顺序栈中的位置。</li>
<li>top = -1 表示空栈。  </li>
</ul>
<h4 id="用C语言描述栈的顺序存储结构"><a href="#用C语言描述栈的顺序存储结构" class="headerlink" title="用C语言描述栈的顺序存储结构"></a>用C语言描述栈的顺序存储结构</h4><pre><code>    #define TRUE 1  
    #define FALSE 0
    #define Stack_Size 50//任意长度
    typedef struct
    &#123;
        StackElementType elem[Stack_Size];//类型
        int top;//指示器
    &#125;SeqStack;//顺序栈
</code></pre>
<h4 id="顺序栈基本操作的实现"><a href="#顺序栈基本操作的实现" class="headerlink" title="顺序栈基本操作的实现"></a>顺序栈基本操作的实现</h4><ul>
<li><p>初始化</p>
<pre><code>  void InitStack(SeqStack *S)
  &#123;
      //构造一个空栈S*
      S-&gt;top = -1;
  &#125;
</code></pre>
</li>
<li><p>判栈空</p>
<pre><code>  int IsEmpty(SeqStack *S)&#123;
      //判栈S为空栈时返回值为真，反之为假
      return(S-&gt;top == -1 ? TRUE : FALSE);
  &#125;
</code></pre>
</li>
<li><p>判栈满</p>
<pre><code>  int IsFull(SeqStack *S)&#123;
      //判栈S为满时返回值为真，反之为假
      return(S-&gt;top == Stack_Size - 1 ? TRUE : FALSE);
  &#125;
</code></pre>
</li>
<li><p>进栈</p>
<pre><code>  int Push(SeqStack *S , StackElementType x)&#123;
      if(S-&gt;top == Stack_Size - 1)//判断栈是否已满
      return(FALSE);
      S-&gt;top++;
      S-&gt;elem[S-&gt;top] = x;
      return(TURE);
  &#125;
</code></pre>
</li>
<li><p>出栈</p>
<pre><code>  int Pop(SeqStack *S , StackElementType *x)&#123;
      if(S-&gt;top == - 1)&#123;
          //判断栈是否已空
      return(FALSE);
      &#125;
      else&#123;
          *x =S-&gt;elem[S-&gt;top];
           S-&gt;top--;
          return(TURE);
      &#125;
  &#125;
</code></pre>
</li>
<li><p>读栈顶元素</p>
<pre><code>   int GetTop(SeqStack *S , StackElementType *x)&#123;
      if(S-&gt;top == - 1)&#123;
          //判断栈是否已空
      return(FALSE);
      &#125;
      else&#123;
          *x =S-&gt;elem[S-&gt;top];
          return(TURE);
      &#125;
  &#125;
</code></pre>
</li>
</ul>
<h4 id="两栈共享的数据结构"><a href="#两栈共享的数据结构" class="headerlink" title="两栈共享的数据结构"></a>两栈共享的数据结构</h4><h5 id="两栈共享栈空间示意图"><a href="#两栈共享栈空间示意图" class="headerlink" title="两栈共享栈空间示意图"></a>两栈共享栈空间示意图</h5><p>利用了栈栈底位置不变 ， 而栈顶位置动态变化的特性为两个栈申请一个共享的一维数组空间S[M]<br>将两个栈的栈底分别为一维数组的两端 0 和 M-1<br>共享栈空间示意： top[0] 和 top[1] 为两个栈顶指示器  </p>
<h5 id="两栈共享的数据结构定义"><a href="#两栈共享的数据结构定义" class="headerlink" title="两栈共享的数据结构定义"></a>两栈共享的数据结构定义</h5><pre><code>    #define M 100
    typedef struct&#123;
        StackElementType Stack[M];//栈区
        int top[2];//两个栈顶指示器
    &#125;DqStack;
</code></pre>
<h5 id="初始化操作算法"><a href="#初始化操作算法" class="headerlink" title="初始化操作算法"></a>初始化操作算法</h5><pre><code>    void InitStack(DqStack *S)&#123;
        S-&gt;top[0] = -1;
        S-&gt;top[1] = M;
    &#125;
</code></pre>
<h5 id="进栈操作算法"><a href="#进栈操作算法" class="headerlink" title="进栈操作算法"></a>进栈操作算法</h5><p>进栈操作步骤：</p>
<ul>
<li><p>进栈需判栈满 S-&gt;top[0] + 1 == S-&gt;top[1]</p>
</li>
<li><p>修改栈顶指针</p>
</li>
<li><p>元素进栈</p>
<pre><code>  int Push(DqStack *S , StackElementType x , int i)&#123;
      if(S-&gt;top[0] + 1 == S-&gt;top[1])//判断栈是否已满
      return(FALSE);
      switch(i)&#123;
          case 0:
              S-&gt;top[0]++;
              S-&gt;Stack[S-&gt;top[0]] = x;
              break;
          case 1:
              S-&gt;top[1]--;
              S-&gt;Stack[S-&gt;top[1]] = x;
              break;
          default:
          return(FALSE);
     &#125;
     return(TRUE)
  &#125;
</code></pre>
</li>
</ul>
<p><img src="/img/stack/stack3.jpg" alt="stack2"></p>
<h5 id="出栈操作算法"><a href="#出栈操作算法" class="headerlink" title="出栈操作算法"></a>出栈操作算法</h5><p>出栈操作步骤：</p>
<ul>
<li><p>出栈需判空</p>
</li>
<li><p>元素出栈</p>
</li>
<li><p>修改栈顶指针</p>
<pre><code>  int Pop(DqStack *S , StackElementType *x , int i)&#123;
      switch(i)&#123;
          case 0:
              if(S-&gt;top[0] == -1)return(FALSE);
              *x = S-&gt;Stack[S-&gt;top[0]];
              S-&gt;top[0]--;
              break;
          case 1:
              if(S-&gt;top[1] == M)
              return(FALSE);
              *x = S-&gt;Stack[S-&gt;top[1]];
              S-&gt;top[1]++;
              break;
          default:
          return(FALSE);
     &#125;
     return(TRUE)
  &#125;
</code></pre>
</li>
</ul>
<h3 id="栈的链式实现"><a href="#栈的链式实现" class="headerlink" title="栈的链式实现"></a>栈的链式实现</h3><h4 id="链栈的定义及示意图"><a href="#链栈的定义及示意图" class="headerlink" title="链栈的定义及示意图"></a>链栈的定义及示意图</h4><p>采用带头结点的单链表实现链栈。<br>头指针就作为指针<br>链栈示意图:<br><img src="/img/stack/stack4.jpg" alt="链栈"></p>
<ul>
<li><p>top 为栈顶指针，始终指向当前栈顶元素前面的头结点。</p>
</li>
<li><p>若 top -&gt; next == NULL , 则代表空栈</p>
<h4 id="用C语言定义的链栈结构"><a href="#用C语言定义的链栈结构" class="headerlink" title="用C语言定义的链栈结构"></a>用C语言定义的链栈结构</h4><pre><code>  typedef struct node&#123;
      StackElementType data;
      struct node *next;
  &#125;LinkStackNode;
  typedef LinkStackNode *LinkStack;
</code></pre>
</li>
</ul>
<h4 id="链栈的进栈操作"><a href="#链栈的进栈操作" class="headerlink" title="链栈的进栈操作"></a>链栈的进栈操作</h4><pre><code>    int Push(LinkStacktop , StackElementType x)&#123;
        LinkStackNode* temp;//将数据元素x压人栈 top 中
        temp = (LinkStackNode*)malloc(sizeof(LinkStackNode));
        if(temp == NULL)return(FALSE);//申请空间失败
        temp-&gt;data = x;
        temp-&gt;next = top-&gt;next;
        top-&gt;next = temp;//修改当前栈顶指针
        return(TRUE);
    &#125;
</code></pre>
<h4 id="链栈的出栈操作"><a href="#链栈的出栈操作" class="headerlink" title="链栈的出栈操作"></a>链栈的出栈操作</h4><pre><code>    int Pop(LinkStacktop , StackElementType *x)&#123;
        LinkStackNode* temp;//将栈 top 的栈顶元素弹出，放到x所指的存储空间中
        temp = top-&gt;next;
        if(temp == NULL)return(FALSE);//栈为空
        top-&gt;next = temp-&gt;next;
        *x = temp-&gt;data;
        free(temp);//释放存储空间
        return(TRUE);
    &#125;
</code></pre>
<h4 id="多栈运算"><a href="#多栈运算" class="headerlink" title="多栈运算"></a>多栈运算</h4><h2 id="栈的应用与递归"><a href="#栈的应用与递归" class="headerlink" title="栈的应用与递归"></a>栈的应用与递归</h2><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>算法思想：利用设置一个括号栈判别左右括号个数与类型匹配的情况</p>
<ul>
<li><p>若读入左括号则入栈，等带相匹配的同类右括号</p>
</li>
<li><p>若读入右括号且与栈顶的左括号类型匹配，栈顶左括号出栈，否则属于不合法</p>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3></li>
<li><p>无括号算术表达式求值  </p>
<pre><code>  运算符优先级
  #  +-  */  **
  0   1   2   3
</code></pre>
</li>
<li><p>算术表达式处理规则</p>
<ol>
<li>规定运算符的优先级表</li>
<li>设置两个栈：OVS（运算数栈）、OPTR（运算符栈）</li>
<li>自左向右扫描，进行如下处理</li>
</ol>
<ul>
<li>遇到 运算数则进 OVS 栈</li>
<li>遇到运算符则与 OPTR 栈的栈顶运算符进行优先级比较：<br>如果当前运算符 &gt;OPTR 栈顶运算符，则当前运算符进 OPTR 栈<br>如果当前运算符&lt;=OPTR 栈顶运算符，则 OPTR 退栈一次，得到栈顶运算符 y, OVS 连续退栈两次，得到运算数 a,b,对 a,b 执行 y 操作，得到结果 T(i) ,将 T(i) 进 VOS 栈。</li>
</ul>
</li>
</ul>
<h3 id="栈与递"><a href="#栈与递" class="headerlink" title="栈与递"></a>栈与递</h3><p>递归：在定义自身的同时又出现了对自身的调用。<br>直接递归函数:在定义的函数体内直接调用自己。<br>间接递归函数：一个函数经过一系列中间调用语句，通过其他函数简介调用自己，如 P 调用 Q ，Q 在调用 P。</p>
<h4 id="递归特性的问题"><a href="#递归特性的问题" class="headerlink" title="递归特性的问题"></a>递归特性的问题</h4><h5 id="递归定义的数学函数"><a href="#递归定义的数学函数" class="headerlink" title="递归定义的数学函数"></a>递归定义的数学函数</h5><ul>
<li><p>二阶Fibonacci数列</p>
<pre><code>  int Fib(int n)&#123;
      if(n == 0)
      return 0;
      if(n == 1)
      return 1 ;
      return Fib(n-1) + Fib(n-2);
  &#125;
</code></pre>
</li>
<li><p>阿克曼函数</p>
<pre><code>  int Ack(int m , int n)&#123;
      if(m == 0)
      return n+1;
      else if(m != 0 &amp;&amp; n == 0)
      return Ack(m-1 , 1);
      else
      return Ack(m-1 , Ack(m , n-1));
  &#125;
</code></pre>
</li>
</ul>
<h5 id="递归数据结构的处理"><a href="#递归数据结构的处理" class="headerlink" title="递归数据结构的处理"></a>递归数据结构的处理</h5><p>如：广义表、二叉树、树等结构其本身均具有固有的递归特性，因此可以自然地采用递归法进行处理。</p>
<h5 id="递归求解方法"><a href="#递归求解方法" class="headerlink" title="递归求解方法"></a>递归求解方法</h5><p>例子：汉诺塔问题的算法实现</p>
<pre><code>    //将塔座X上编号为1至 n 的 n 个由小到大圆盘按规则搬到塔座 Z 上，Y 可用作辅助塔座
    void hanoi(int n , char y , char z)&#123;
        if(n == 1)&#123;
            move(x,1,z)//将编号为1的圆盘从 X 移动到 Z
        &#125;
        else&#123;
            hanoi(n-1 , x , z , y);//将 X 上编号为 1 至 n-1 的圆盘移到 Y,Z 作辅助塔
            move(x , n , z);//将编号为 n 的圆盘从 X 移动到 Z
            hanoi(n-1 , y , x , z);//将 y 上编号为1至 n-1 的圆盘移动到 z , x作辅助塔
        &#125;
        
    &#125;
</code></pre>
<h5 id="递归问题的优点"><a href="#递归问题的优点" class="headerlink" title="递归问题的优点"></a>递归问题的优点</h5><ul>
<li>对递归问题描述简洁</li>
<li>结构清晰</li>
<li>程序的正确性容易证明</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基于HeadFirst设计模式之观察者模式</title>
    <url>/2018/06/11/design/HeadFirst-Subject-Observer/</url>
    <content><![CDATA[<p>好，我们接着上一篇继续介绍下一个设计模式 观察者模式<br>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖的对象都会受到通知并自动更新</p>
<h2 id="确定接口"><a href="#确定接口" class="headerlink" title="确定接口"></a>确定接口</h2><p>首先写我们的接口 被观察者 和 观察者</p>
<pre><code>//被观察者接口
public interface Subject
&#123;
    //注册观察者
    void RegisterObserver(Observer o);
    //删除观察者
    void RemoveObserver(Observer o);
    //当被观察者状态发生改变时，调用此方法 通知所有的观察者
    void NotifyObserver();
&#125;
//观察者接口
public interface Observer
&#123;
    void Update();//所有的观察者都必须实现此方法，来实现观察者的接口
    void Display()；//当观察者需要作出响应的时候调用此方法
&#125;
</code></pre>
<h2 id="创建被观察者对象"><a href="#创建被观察者对象" class="headerlink" title="创建被观察者对象"></a>创建被观察者对象</h2><pre><code>public class WeatherData:Subject
&#123;
    public ArrayList observers //存储所有的观察者，在构造中初始化
    
    public WeatherData()
    &#123;
        observers=new ArrayList();
    &#125;

     public void NotifyObserver()//通知所有观察者发生改变
    &#123;
        for (int i = 0; i &lt; observers.Count; i++)
        &#123;
            Observer o = (Observer)observers[i];
            o.Update();
        &#125;
    &#125;

    public void RegisterObserver(Observer o)//注册观察者
    &#123;
        observers.Add(o);
    &#125;

    public void RemoveObserver(Observer o)//删除观察者
    &#123;
        int index = observers.IndexOf(o);
        if (observers.Count&gt;0)
        &#123;
            observers.Remove(index);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="创建观察者对象"><a href="#创建观察者对象" class="headerlink" title="创建观察者对象"></a>创建观察者对象</h2><pre><code>//实现 Observer 接口，和 displayelement 接口 

public class ConditionDisplay : Observer
&#123;
    private Subject weatherdata;
    private string weathername;
    public CurrentConditionDisplay(Subject s,string name)//构造器需要subject对象 和观察者的名字
    &#123;
        weatherdata = s;//保存被观察者只是为了以后我们可能会取消注册，会比较方便
        weatherdata.RegisterObserver(this);
        this.weathername = name;
    &#125;
    public void Remove()//取消注册
    &#123;
        waterdata.RemoveObserver(this);
    &#125;
    public void Display()//接到通知后自己做出相应的响应
    &#123;
        Console.WriteLine(watername + &quot;发出相应的改变&quot;);
    &#125;

    public void Update()//接受观察者的通知
    &#123;
        Console.WriteLine(watername+&quot; 已经接到通知&quot;);
        Display();//这个方法目前先在Update方法中调用（详细讲解请看MVC模式）
    &#125;
&#125;
</code></pre>
<h3 id="创建一个测试程序"><a href="#创建一个测试程序" class="headerlink" title="创建一个测试程序"></a>创建一个测试程序</h3><pre><code>public static void Station
&#123;
    public static void Main(string[] arg)
    &#123;
        Subject subject=new weatherdata();
        Observer o1 = new CurrentConditionDisplay(subject,&quot;小明&quot;);
        Observer o2 = new CurrentConditionDisplay(subject,&quot;小红&quot;);
        Observer o3 = new CurrentConditionDisplay(subject,&quot;小李&quot;);
        subject.NotifyObserver();
        o2.Remove();
        Console.WriteLine(&quot;________________________________&quot;);
        subject.NotifyObserver();
        
        
    &#125;
&#125;
</code></pre>
<p>以上就是观察者模式了，上面涉及到 Display() 方法调用的时机，了解 MVC 模式之后会更清楚，后续会更新其他的设计模式，敬请期待…
    </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于HeadFirst设计模式之装饰者模式</title>
    <url>/2018/06/14/design/HeadFirst-garnisher/</url>
    <content><![CDATA[<a id="more"></a>
<p>想必大家都知道面向对象编程中继承的好处，也知道继承在某些需求上能发挥很大的作用。但是滥用继承关系会造成：类爆炸，设计死板，基类加入的新功能不适用于所有子类等问题。所以大家要慎用。下面这个设计模式只用简单的继承是完不成我们想要的需求的,我们应该使用组合来是系统更有弹性并且易于维护。  </p>
<h3 id="开放-关闭原则："><a href="#开放-关闭原则：" class="headerlink" title="开放-关闭原则："></a>开放-关闭原则：</h3><p><font color = #ff0000 size = 4 >类应该对扩展开放，对修改关闭</font></p>
<h3 id="初识装饰者模式"><a href="#初识装饰者模式" class="headerlink" title="初识装饰者模式"></a>初识装饰者模式</h3><p>例：星巴兹是以狂战速度最快而闻名的咖啡连锁店。因为扩张速度实在太快，他们最北更新订单系统，以合乎他们的饮料供应要求。<br>咖啡类型： DarkRoast ，HouseBlend , Espresso , Decaf 。<br>调料：Milk , Mocha , Soy , Whip 。</p>
<h4 id="定义装饰者模式"><a href="#定义装饰者模式" class="headerlink" title="定义装饰者模式"></a>定义装饰者模式</h4><pre><code>动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
</code></pre>
<h4 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h4><ul>
<li>装饰者和被装饰者对象有相同的超类型。</li>
<li>可以用一个或多个装饰者包装一个对象。</li>
<li>几人装饰者和被装饰者对象有相同的超类型，所有在任何需要原始对象的场合，可以用装饰过的对象代替它。</li>
<li><font color = #ff0000 size = 4 >装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</font></li>
<li>对象可以在任何时候被装饰，所以可以在运行的时候动态地，不限量的用你喜欢的装饰者来装饰对象。  </li>
</ul>
<p>下面是装饰者模式的类图<br><img src="/img/garnisher/garnisher.png" alt="avatar"></p>
<h4 id="例子的解决方案"><a href="#例子的解决方案" class="headerlink" title="例子的解决方案"></a>例子的解决方案</h4><h5 id="用装饰者完成饮料模型的类图"><a href="#用装饰者完成饮料模型的类图" class="headerlink" title="用装饰者完成饮料模型的类图"></a>用装饰者完成饮料模型的类图</h5><p><img src="/img/garnisher/beverage.png" alt="avatar">  </p>
<h5 id="然后我们写下星巴兹的代码"><a href="#然后我们写下星巴兹的代码" class="headerlink" title="然后我们写下星巴兹的代码"></a>然后我们写下星巴兹的代码</h5><p>首先是Beverage类：</p>
<pre><code>public abstract class Beverage
&#123;
    string description = &quot;UnKnow Beverage&quot;;
    public string GetDescription()
    &#123;
        return description;
    &#125;
    public abstract double Cost();
&#125;
</code></pre>
<p>然后实现调料的抽象类，也就是装饰者类：  </p>
<pre><code>//首先必须让CondimentDecorator能够代替Beverage ,所以讲此类继承自Beverage
public abstract class CondimentDecorator : Beverage
&#123;
    //所有的调料必须重写GetDescription方法。
    public abstract string GetDescription();
&#125; 
</code></pre>
<p>下面是饮料的代码：</p>
<pre><code>public class Espresso : Beverage
&#123;

    public Espresso()
    &#123; 
        description=&quot;Espresso&quot;; 
    &#125;

    public double Cost()
    &#123;
        return 1.99;
    &#125;
&#125;

public class HouseBlend : Beverage
&#123;
    
    public HouseBlend()
    &#123; 
        description=&quot;HouseBlend&quot;; 
    &#125;

    public double Cost()
    &#123;
        return 0.89;
    &#125;
&#125;

public class DarkRoast : Beverage
&#123;
    
    public DarkRoast()
    &#123; 
        description=&quot;DarkRoast&quot;; 
    &#125;

    public double Cost()
    &#123;
        return 0.99;
    &#125;
&#125;

public class Decaf : Beverage
&#123;
    
    public Decaf()
    &#123; 
        description=&quot;Decaf&quot;; 
    &#125;

    public double Cost()
    &#123;
        return 1.05;
    &#125;
&#125;
</code></pre>
<p>然后是调料的代码： </p>
<pre><code>public class Mocha : CondimentDecorator
&#123;
    Beverage beverage;
    public Mocha(Beverage beverage)
    &#123; 
       this.beverage = beverage;  
    &#125;
    public string GetDescription()
    &#123;
        return beverage.GetDescription() + &quot;,Mocha&quot;;
    &#125;
    public double Cost()
    &#123;
        return 0.20 + beverage.Cost();
    &#125;
&#125;

public class Soy : CondimentDecorator
&#123;
    Beverage beverage;
    public Soy(Beverage beverage)
    &#123; 
       this.beverage = beverage;  
    &#125;
    public string GetDescription()
    &#123;
        return beverage.GetDescription() + &quot;,Soy&quot;;
    &#125;
    public double Cost()
    &#123;
        return 0.15 + beverage.Cost();
    &#125;
&#125;

public class Whip : CondimentDecorator
&#123;
    Beverage beverage;
    public Whip(Beverage beverage)
    &#123; 
       this.beverage = beverage;  
    &#125;
    public string GetDescription()
    &#123;
        return beverage.GetDescription() + &quot;,Whip&quot;;
    &#125;
    public double Cost()
    &#123;
        return 0.10 + beverage.Cost();
    &#125;
&#125;

public class Milk : CondimentDecorator
&#123;
    Beverage beverage;
    public Milk(Beverage beverage)
    &#123; 
       this.beverage = beverage;  
    &#125;
    public string GetDescription()
    &#123;
        return beverage.GetDescription() + &quot;,Milk&quot;;
    &#125;
    public double Cost()
    &#123;
        return 0.15 + beverage.Cost();
    &#125;
&#125;
</code></pre>
<p>剩下的就是测试代码了：  </p>
<pre><code>public static class Main(string args[])
&#123;
    Beverage beverage = new Espresso();
    beverage = new Mocha(beverage);
    beverage = new Whip(beverage);
    Console.WriteLine(beverage.GetDescription() + &quot;$&quot; + beverage.Cost());
&#125;
</code></pre>
<p>装饰者有能力为设计注入弹性，但是也有不好的地方，有时候会在设计中加入大量的小类，会导致别人不容易了解我的设计方式。<br>采用装饰者在实例化组件时，将增加代码的复杂度，一旦使用装饰者模式，不只需要实例化组件，还要把此组件包装进装饰者中，天知道有多少个。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于HeadFirst设计模式之策略模式</title>
    <url>/2018/06/09/design/HeadFirst/</url>
    <content><![CDATA[<p>最近在看一本书 HeadFirst 设计模式感觉还不错，下面会对这本书所涉及到的几种设计模式分析一下<br>下面书中所介绍的第一个设计模式 入门级的  策略模式<br>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户<br>下面具体根据例子来讲解 （针对超类型编程）<br>模拟鸭子应用<br>1.鸭子 fly swim quack…<br>首先根据鸭子的行为设计两个接口 FlyBehavior  QuackBehavior</p>
<pre><code>interface FlyBehavior
&#123;
    void Flying();
&#125;
interface QuackBehavior
&#123;
    void Quacking();
&#125;
</code></pre>
<p>然后在设计对应的类，负责实现具体的行为</p>
<pre><code>public class FlyWithWings:FlyBehavior
&#123;
    public void Flying()
    &#123;
        print(&quot;I&#39;m flying...&quot;);
    &#125;
&#125;
public class FlyNoWay:FlyBehavior
&#123;
    public void Flying()
    &#123;
        //什么都不做
        print(&quot;I can not fly&quot;);
    &#125;
&#125;
public class Quack:QuackBehavior
&#123;
    public void Quacking()
    &#123;
        print(&quot;鸭子呱呱叫...&quot;);
    &#125;
&#125;
public class Squeak:QuackBehavior
&#123;
    public void Quacking()
    &#123;
        print(&quot;橡皮鸭子吱吱叫...&quot;);
    &#125;
&#125;
public class MuteQuack:QuackBehavior
&#123;
    public void Quacking()
    &#123;
        //什么都不做
        print(&quot;不会叫...&quot;);
    &#125;
&#125;
</code></pre>
<p>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子没有关系了</p>
<p>而我们新增的一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行类的鸭子类</p>
<p>我们整合一下鸭子的行为<br>关键在于，鸭子现在会将飞行和叫的动作委托别人处理，而不是定义在 Duck（或者子类）内的呱呱叫和飞行的方法<br>下面我们写一下超类 Duck</p>
<pre><code>public abstract class Duck
&#123;
    //为行为接口类型声明两个引用变量，所有的鸭子类都继承他们
    public FlyBehavior flyBehavior;
    public QuackBehavior quackBehavior;
    
    public abstract void display();
    
    public void PerfromFly()
    &#123;
        flyBehavior.Flying();
    &#125;
    public void PerfromQuack()
    &#123;
        quackBehavior.Quacking();
    &#125;
    
&#125;
</code></pre>
<p>我们来看一下如何设定 flyBehavior 和 quackBehavior 的实例变量    </p>
<pre><code>public class MallardDuck:Duck
&#123;
    public MallardDuck()
    &#123;
        //使用 Quack 类处理呱呱叫，当 PerfromQuack() 被调用时叫的职责被委托给 Quack 对象，而我们得到了真正的呱呱叫
        quackBehavior=new Quack();
        //使用 FlyWithWings 作为其 FlyBehavior 类型
        flyBehavior=new FlyWithWings();
    &#125;
    
    public void display()
    &#123;
        print(&quot;I&#39;m a real Mallard duck&quot;);
    &#125;
&#125;
</code></pre>
<p>编译测试类</p>
<pre><code>public class MiniDucks
&#123;
    public static void Main(string[] arg)
    &#123;
        Duck mallard =new MallardDuck();
        mallard.PerfromFly();//这个会调用 MallardDuck 继承来的 PerfromFly() 方法，进而委托给该对象的 FlyBehavior 对象处理
        mallard.PerfromQuack();
    &#125;
&#125;
</code></pre>
<p>动态设定行为<br>在鸭子里建立了一堆动态功能没有用到，就太可惜了！ 假设我们想在鸭子的子类中通过设定方法（set）来设定鸭子的行为<br>而不是在鸭子的构造器内实例化<br>在 Duck 类中加入两个新的方法</p>
<pre><code>public void SetFlyBehavior(FlyBehavior fb)
&#123;
    flyBehavior=fb;
&#125;
public void SetQuackBehavior(QuackBehavior qb)
&#123;
    quackBehavior=qb;
&#125;
</code></pre>
<p>以后我们可以随时调用这两个方法改变鸭子的行为。</p>
<p>添加一个新的鸭子类型</p>
<pre><code>public class ModelDuck:Duck
&#123;
    public ModelDuck()
    &#123;
        flyBehavior=new FlyNoWay();
        quackBehavior=new Quack();
    &#125;
    public void display()
    &#123;
        print(&quot;I&#39;m a model duck&quot;);
    &#125;
&#125;
</code></pre>
<p>建立一个新的 FlyBehavior 类型</p>
<pre><code>public class FlyRocketPowered : FlyBehavior
&#123;
    public void Flying()
    &#123;
        print(&quot;I&#39;m flying with rocket!&quot;);
    &#125;
&#125;
</code></pre>
<p>改变测试类</p>
<pre><code>public class MiniDucks
&#123;
    public static void Main(string[] arg)
    &#123;
        Duck model =new ModelDuck();
        model.PerfromFly();
        model.SetFlyBehavior(new FlyRocketPowered());
        model.PerfromFly();
    &#125;
&#125;
</code></pre>
<p>在运行时想改变鸭子的行为，只需要调用鸭子的Set方法就可以。</p>
<p>当你需要给朋友留下深刻的印象，或是想影响关键主管的决策时，请使用策略模式的定义</p>
<p>OK！ 策略模式到这里就结束了，这只是第一种模式，后面还会陆续更新其他的设计模式 敬请期待…</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于HeadFirst设计模式之工厂模式</title>
    <url>/2018/07/16/design/headfirst-factory/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="定义简单工厂"><a href="#定义简单工厂" class="headerlink" title="定义简单工厂"></a>定义简单工厂</h2><p>简单工厂其实不是一种设计模式，比较像一种编程习惯。但由于经常被使用，所以给它一个“ Head First Patter 荣誉奖”。有些开发人员的确是把这个编程习惯误认为是“工厂模式” ,下次跟开发的朋友聊天无话可说的时候，这个应该是打破沉默的一个不错的选择。  </p>
<p>不要因为简单工厂不是一个“真正的设计模式” ， 就忽略的它的用法。</p>
<p>我们先看一下披萨店例子的类图：  </p>
<p><img src="/img/factory/factory.png" alt="factory"></p>
<p>这就是简单工厂，下面要说的就是两个重量级的模式，它们都是工厂。</p>
<p>这里提醒一下：<br><font color=red>在设计模式中，所谓的“实现一个接口”并“不一定”表示“写一个类” ，并继承这个接口。“实现一个接口”泛指“实现某个超类型（可以是类或者接口）的某个方法”</font></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将兑现该创建的过程封装的目的。下面我们看一组类图来了解一下有哪些组成元素</p>
<ul>
<li><p>创建者( Creator ) 类<br><img src="/img/factory/factory2.png" alt="factory2"></p>
</li>
<li><p>产品类<br><img src="/img/factory/factory3.png" alt="factory3"></p>
</li>
</ul>
<p>我们已经看到，将一个 orderPizza() 方法和一个工厂方法联合起来，就可以成为一个框架。除此之外，工厂方法将生产只是封装进各个创建者，这样的做法，也可以被视为一个框架。</p>
<p><img src="/img/factory/factory4.png" alt="factory4"></p>
<h3 id="定义工厂方法模式"><a href="#定义工厂方法模式" class="headerlink" title="定义工厂方法模式"></a>定义工厂方法模式</h3><p>工厂方法模式：定义了一个创建对象的接口，但由于子类决定要实例化的类的哪个，工厂方法让类把实例化推迟到子类。</p>
<p>工厂方法模式能够封装具体类型的实例化。看下面的类图，抽象的 Creator 提供了一个创建对象的方法的接口，也成为”工厂方法“。在抽象的 Creator 中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法并创建产品。</p>
<p><img src="/img/factory/factory5.png" alt="factory5"></p>
<h2 id="对象依赖"><a href="#对象依赖" class="headerlink" title="对象依赖"></a>对象依赖</h2><p>当你实例化一个对象时，就是在依赖它的具体类。</p>
<p><img src="/img/factory/factory6.png" alt="factory6"></p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>设计原则：<br><font color=red>要依赖抽象，不要依赖具体类</font><br>意思就是：不能让高层组件依赖底层组件，而且，不管高层或底层组件，“两者”都应该依赖于抽象。</p>
<p>所以在应用工厂方法之后，类图看起来就像这样：<br><img src="/img/factory/factory7.png" alt="factory7"></p>
<p>高层组件（也就是 PizzaStore ）和底层组件（也就是这些比萨）都依赖了 Pizza 抽象。想要遵循依赖倒置原则，工厂方法并非是唯一的技巧，但却是最有威力的技巧之一。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽线工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体的产品是什么。这样客户就从具体的产品中被解耦。我们看一下下面的类图了解一下其中的关系。</p>
<p><img src="/img/factory/factory8.png" alt="factory8"></p>
<p>我们再从 PizzaStore 的观点看下面这张相当复杂的类图：</p>
<p><img src="/img/factory/factory9.png" alt="factory9"></p>
<p>这里细心的朋友已经观察到了，抽象工厂的每个方法实际上看起来都像是工厂方法（例如；createDough() , createSource() 等）。每个方法都被声明成抽象，而子类的方法覆盖这些方法来创建某些对象。这不正是工厂方法吗？是的，抽象工厂的方法经常以工厂方法的方式实现，抽象工厂的任务是定义一个负责创建一组产品的接口。这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法。所以，在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。</p>
<h3 id="代码示例（比萨店）"><a href="#代码示例（比萨店）" class="headerlink" title="代码示例（比萨店）"></a>代码示例（比萨店）</h3><ul>
<li><p>创建原料工厂</p>
<pre><code>  public interface PizzaIngredientFactory()
  &#123;
      public Dough CreateDoough();
      public Sauce CreateSauce();
      public Clam CreateClam();
      ...
  &#125;
</code></pre>
</li>
<li><p>创建纽约原料工厂</p>
<pre><code>  public class NYPizzaIngredientFactory : PizzaIngredientFactory&#123;
      public Dough createDough()&#123;
          return new ThinCrustDough();
      &#125;

      public Dough createSauce()&#123;
          return new MarinaraSauce();
      &#125;

       public Clam createClam()&#123;
          return new FreshClams();
      &#125;
  &#125;
</code></pre>
</li>
<li><p>比萨抽象类</p>
<pre><code>  public abstract class Pizza
  &#123;
      string name;
      Dough dough;
      Sauce sauce;

      abstract void prepare();

      void Bake()&#123;
          print(&quot;bake...&quot;);
      &#125;

      void cut()&#123;
          print(&quot;cut&quot;);
      &#125;

      void Box()
      &#123;
          print(&quot;box&quot;);
      &#125;

      void SetName(string name)&#123;
          this.name = name;
      &#125;

      string GetName()&#123;
          return name;
      &#125;

  &#125;
</code></pre>
</li>
<li><p>CheesePizza 类</p>
<pre><code>  public class CheesePizza : Pizza&#123;
      PizzaIngredientFactory ingredientFactory;
      public CheesePizza(PizzaIngredientFactory ingredientFactory)&#123;
          this.ingredientFactory = ingredientFactory;
      &#125;

      void prepare()&#123;
          print(&quot;prepare&quot; + name)
          dough = ingredientFactory.CreateDough();
          sauce = ingredientFactory.CreateSauce();
      &#125;
  &#125;
</code></pre>
</li>
<li><p>ClamPizza 类</p>
<pre><code>  public class ClamPizza : Pizza&#123;
      PizzaIngredientFactory ingredientFactory;
      public CheesePizza(PizzaIngredientFactory ingredientFactory)&#123;
          this.ingredientFactory = ingredientFactory;
      &#125;

      void prepare()&#123;
          print(&quot;prepare&quot; + name)
          dough = ingredientFactory.CreateDough();
          sauce = ingredientFactory.CreateSauce();
          clam = ingredientFactory.CreateClam();
      &#125;
  &#125;
</code></pre>
</li>
<li><p>比萨店</p>
<pre><code>  public abstract class PizzaStore
  &#123;
      //这里定义一个工厂方法
      abstract Pizza createPizza(string item);
      public Pizza orderPizza(string type) 
      &#123;
          Pizza pizza = createPizza(type);
          print(&quot;--- Making a &quot; + pizza.getName() + &quot; ---&quot;);
          pizza.prepare();
          pizza.bake();
          pizza.cut();
          pizza.box();
          return pizza;
      &#125;
  &#125;

  public class NYPizzaStore : PizzaStore
  &#123;
      protected Pizza CreatePizza(string name)&#123;
          Pizza pizza = null;
          PizzaIngredientFactory ingredientFactory = new PizzaIngredientFactory();

          if(name.Equals(&quot;cheese&quot;))&#123;
              pizza = new CheesePizza(ingredientFactory);
              pizza.SetName(&quot;New York Style Cheese Pizza&quot;);
          &#125;
          else if(name.Equals(&quot;clam&quot;))&#123;
              pizza = new ClamPizza(ingredientFactory);
              pizza.SetName(&quot;New York Style Clam Pizza&quot;);
          &#125;
          ...
      &#125;
  &#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2018/07/30/design/proxy%20Pattern/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近自己正在研究一套自己的 AssetBundle 框架。想到代理模式非常适合这个框架的开发，所以在此提前先简单介绍一下代理模式</p>
<h2 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h2><p>定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<h2 id="代理模式的组成"><a href="#代理模式的组成" class="headerlink" title="代理模式的组成"></a>代理模式的组成</h2><p>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。</p>
<p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
<p>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<h2 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><p>职责清晰</p>
</li>
<li><p>高扩展性</p>
</li>
<li><p>代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li><p>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</p>
</li>
<li><p>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
</li>
</ul>
<h3 id="代理模式的实现"><a href="#代理模式的实现" class="headerlink" title="代理模式的实现"></a>代理模式的实现</h3><p>我们这里借用一下菜鸟教程的例子-<a href="http://www.runoob.com/design-pattern/proxy-pattern.html">菜鸟教程</a>  </p>
<p>例：创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。<br>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。</p>
<p><img src="/img/pattern/proxy_pattern_uml.jpg" alt="UML类图"></p>
<h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><pre><code>public interface Image &#123;
    void Display();
&#125;
</code></pre>
<h4 id="创建实现接口的实体类"><a href="#创建实现接口的实体类" class="headerlink" title="创建实现接口的实体类"></a>创建实现接口的实体类</h4><p>真实角色</p>
<pre><code>public class RealImage : Image &#123;

    private string fileName;
    
    public RealImage(string fileName)&#123;
        this.fileName = fileName;
        LoadFromDisk(fileName);
    &#125;
    
    public void Display() &#123;
        print(&quot;Displaying &quot; + fileName);
    &#125;
    
    private void LoadFromDisk(string fileName)&#123;
        print(&quot;Loading &quot; + fileName);
    &#125;
&#125;
</code></pre>
<p>代理角色</p>
<pre><code>public class ProxyImage : Image&#123;

    private RealImage realImage;
    private string fileName;
    
    public ProxyImage(string fileName)&#123;
        this.fileName = fileName;
    &#125;
    
    public void Display() &#123;
        if(realImage == null)&#123;
            realImage = new RealImage(fileName);
        &#125;
        realImage.Display();
    &#125;
&#125;
</code></pre>
<h4 id="当被请求时，使用-ProxyImage-来获取-RealImage-类的对象"><a href="#当被请求时，使用-ProxyImage-来获取-RealImage-类的对象" class="headerlink" title="当被请求时，使用 ProxyImage 来获取 RealImage 类的对象"></a>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象</h4><pre><code>public class ProxyPatternDemo &#123;

    public static void main(string[] args) &#123;
        Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);
    
        //图像将从磁盘加载
        image.Display(); 
        print(&quot;&quot;);
        //图像将无法从磁盘加载
        image.Display();  
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记下</title>
    <url>/2018/06/07/git/git-2/</url>
    <content><![CDATA[<h2 id="git-标签"><a href="#git-标签" class="headerlink" title="git 标签"></a>git 标签</h2><ul>
<li>轻标签  <ul>
<li>添加名称</li>
</ul>
</li>
<li>注解标签  <ul>
<li>添加名称</li>
<li>添加注解</li>
<li>添加签名  </li>
</ul>
</li>
</ul>
<p>一般情况下，发布标签采用的注解标签来添加注解或者标签。<br>添加轻标签的命令  </p>
<pre><code>git tag &lt;tagName&gt;
</code></pre>
<p>查看标签  </p>
<pre><code>git tag
</code></pre>
<p>在 log 命令添加 –decorate 选项执行, 可以显示包含标签的提交记录。  </p>
<pre><code>git log --decorate
</code></pre>
<p>添加注解标签  </p>
<pre><code>git tag -a &lt;tagName&gt;
git tag -am &quot;这里是注解&quot; &lt;tagName&gt;
</code></pre>
<p>显示标签的列表和注解  </p>
<pre><code>git tag -n
</code></pre>
<p>删除标签  </p>
<pre><code>git tag -d &lt;tagName&gt;
</code></pre>
<h2 id="git-改写提交"><a href="#git-改写提交" class="headerlink" title="git 改写提交"></a>git 改写提交</h2><ul>
<li><p>修改最近的提交记录  </p>
<pre><code>  git commit --amend
</code></pre>
</li>
<li><p>取消过去的提交  </p>
<pre><code>  git revert HEAD (这里是取消最近的一次提交)
</code></pre>
</li>
<li><p>遗弃提交 reset<br>在这行 reset 的时候根据影响的范围选择不同的模式。<br>主要使用的场合：  </p>
<ol>
<li>复原修改过的索引的状态(mixed)</li>
<li>彻底取消最近的提交(hard)</li>
<li>只取消提交(soft)  </li>
</ol>
<p>命令：删除最近一次提交  </p>
<pre><code>  git reset --hard HEAD~
</code></pre>
<p>在 reset 错误的时候可以执行下面的命令来回到 reset 之前的状态。  </p>
<pre><code>  git reset --hard ORIG_HEAD
</code></pre>
<p>详细表格：  </p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">模式名称</th>
<th align="center">HEAD的位置</th>
<th align="center">索引</th>
<th align="center">工作树</th>
</tr>
</thead>
<tbody><tr>
<td align="center">soft</td>
<td align="center">修改</td>
<td align="center">不修改</td>
<td align="center">不修改</td>
</tr>
<tr>
<td align="center">mixed</td>
<td align="center">修改</td>
<td align="center">修改</td>
<td align="center">不修改</td>
</tr>
<tr>
<td align="center">hard</td>
<td align="center">修改</td>
<td align="center">修改</td>
<td align="center">修改</td>
</tr>
</tbody></table>
<ul>
<li><p>复制提交<br>从其他的分支上将某次提交导入到 master 分支上，执行以下命令： </p>
<pre><code>git checkout master   

git cherrypick &lt;hash&gt;
</code></pre>
<p>  如果有冲突修改就好。</p>
</li>
<li><p>修改提交</p>
<pre><code>  git rebase -i &lt;commit&gt;
</code></pre>
<p>  再次提交会显示提交的清单，在提交清单里找出要修改的提交，将”pick”改成”edit”,然后保存。等到文件修改后执行：  </p>
<pre><code>  git commit --amend
</code></pre>
<p>  最后,指定 –continue 选项来执行 rebase。  </p>
<pre><code>  git rebase --continue
</code></pre>
</li>
<li><p>汇合分支上的提交,然后合并到分支<br>这一操作要用到 merge 的特殊选项 squash<br>操作命令：</p>
<pre><code>  git checkout master  
  git merge --squash &lt;otherbranch&gt;
</code></pre>
<p>  这样 otherbranch 分支上的所有提交都合并到 master 分支上了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记上</title>
    <url>/2018/06/05/git/git/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="git-入门"><a href="#git-入门" class="headerlink" title="git 入门"></a>git 入门</h2><p>git 就是在任意时间把文档的状态作为更新记录保存起来，这样可以在编辑过的文档中任意切换或操作之前的状态。并且在覆盖较新的文件是会发出警告，避免无意中覆盖他人的编辑内容。<br>提交本地数据的内容时会生成上次提交的状态与当前状态的差异记录（按时间排列），这样就可以知道之前的修改内容了。  </p>
<ul>
<li>注意：不同的内容尽量分开提交（比如： bug 修复和功能添加），这样方便查找和修改。</li>
<li>解决冲突：如果远程数据库和本地数据库的同一个地方都发生修改的情况，在推送的时候就会发生合并冲突。解决办法就是将远程数据库的文件 pull 下来,手动修改冲突位置（将远程仓库和本地仓库冲突的内容全部保留，然后删除掉提示行）。重新提交，最后 push 到远程仓库就可以了。  </li>
</ul>
<h2 id="git-高级"><a href="#git-高级" class="headerlink" title="git 高级"></a>git 高级</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>再开发软件的时候可能会存在不同的开发人员开发不同的功能或者修复 bug ，也可能存在多个 release 版本，并且需要同时维护。这样通过分支就可以做到同时进行并且互不影响，在工作完成之后再合并到主分支上。这样在发生问题的时候就会很容易定位和修改。</p>
<h4 id="分支运用的规则"><a href="#分支运用的规则" class="headerlink" title="分支运用的规则"></a>分支运用的规则</h4><ul>
<li>Merge 分支<br>Merge 分支是为发布 release 版本而创建的分支，可以作为 Topic 的源分支，重要的事保持分支稳定的状态，一般情况下会把 master 分支当做 Merge 分支。 </li>
<li>Topic 分支<br>Topic 分支是为了开发新功能或者修复 bug 而创建的分支。当分支工作完成之后再合并到 Merge 分支上。  </li>
</ul>
<p>分支创建命令   </p>
<pre><code>git branch &lt; branchName &gt;  
</code></pre>
<p>分支删除命令  </p>
<pre><code>git branch -d &lt; branchName &gt;  
</code></pre>
<h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>分支切换命令  </p>
<pre><code>git checkout &lt; branchName &gt;  
</code></pre>
<p>在分支切换前 git 会把工程还原到目标分支上次提交的内容处， checkout 之后提交的记录会追加到目标分支的历史记录中。</p>
<ul>
<li>HEAD<br>HEAD是指向正在使用的分支的最后一次更新，可以通过 HEAD 的移动来改变使用的分支。</li>
<li>stash<br>在你切换分支之前，你的工程中修改的或者新加的文件内容没有提交。切换分支之后这些内容将会移到目标分支中。但是如果目标分支也修改了这些文件，则在 checkout 时会失败，解决这个问题有两种办法：  <ul>
<li>在切换分支前先将这些修改的内容提交，然后在切换分支</li>
<li>用 stash 暂时保存工程中还没有提交过的修改的内容，事后在拿出来应用到原先的分支上，或者其他的分支。  </li>
</ul>
</li>
</ul>
<h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>例：bugfix 分支是从主分支（ master ）分叉处来的。  </p>
<ul>
<li>merge  <ul>
<li>在合并之前如果 master 分支没有做任何的修改，那合并很简单直接将修改的 bugfix 分支合并到 master 分支上（也就是将 master 分支的位置移动到 bugfix 分支上） bugfix 分支上的历史记录包含所有 master 分支的记录， Git 就会合并。 fast-forward (快进)合并。</li>
<li>如果 master 分支在 bugfix 分支分出去之后也有修改这样在合并的时候两个分支修改的内容合起来生成一个新的提交，并且 master 分支的 HEAD 将移动到新生成的提交上。</li>
</ul>
</li>
<li>rebase<br>将 bugfix 分支 rebase 到 master 分支上(命令： git rebase master )就是把 bugfix 分支的历史记录放到 master 分支的记录后面，然后提交 bugfix 分支的内容。提交过程中可能会发生冲突，修改冲突就好（命令： git add file , git rebase –continue )。在 rebase 的时候，修改冲突后不是使用 commit 命令，而是执行 rebase 命令指定 –continue 选项。如果要取消 rebase ，指定 –abort 选项。在 rebase 之后 master 的 HEAD 的位置并未改变，所以合并两个分支就是将 master 分支的 HEAD 移动到 bugfix 分支的 HEAD 位置上（命令： git merge bugfix ）。  </li>
</ul>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>merge 和 rebase 合并都是合并历史记录，但有各自的特征</p>
<ul>
<li>merge<br>保持修改内容的历史记录，但是历史记录会很复杂。</li>
<li>rebase<br>历史记录简单,就是将原有的提交的基础上将差异内容反映进去。但是在提交的工程中可能会发生冲突.</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity_ShaderGraph 节点之 Artistic Nodes</title>
    <url>/2018/08/24/shadergraph/ShaderGraph%20_Artistic%20Nodes/</url>
    <content><![CDATA[<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>节点中很多输入为In(1)的其实是动态长度的Vector，可以接收Vector1~Vector4的值。</p>
<h3 id="Adjustment-调整"><a href="#Adjustment-调整" class="headerlink" title="Adjustment 调整"></a>Adjustment 调整</h3><h4 id="Channel-Mixer"><a href="#Channel-Mixer" class="headerlink" title="Channel Mixer"></a>Channel Mixer</h4><p>根据输入的RGB值及各个通道的权重，输出权重加成后的RGB值。<br><img src="/img/shadergraph/Artistic/node1.png" alt="Channel"></p>
<p>比如：输入 RGB 为（0.5,0.6,0.7），假设输出 R 通道的比重设置为（0.1,0.2,0.3），则输出的 R 值为<br> 0.5 * 0.1 + 0.6 * 0.2 + 0.7 * 0.3 = 0.249<br><img src="/img/shadergraph/Artistic/node2.png" alt="Channel"></p>
<pre><code>_Node_OutRed = float3 (OutRedInRed, OutRedInGreen, OutRedInBlue);
_Node_OutGreen = float3 (OutGreenInRed, OutGreenInGreen, OutGreenInBlue);
_Node_OutBlue = float3 (OutBlueInRed, OutBlueInGreen, OutBlueInBlue);
Out = float3(dot(In, _Node_OutRed), dot(In, _Node_OutGreen), dot(In, _Node_OutBlue));
</code></pre>
<h4 id="Contrast-对比度调节"><a href="#Contrast-对比度调节" class="headerlink" title="Contrast 对比度调节"></a>Contrast 对比度调节</h4><p>根据输入 In 及 Contrast 调节对比度。 Contrast 为1时输出 In , Contrast 为0时输出 In 的中值<br><img src="/img/shadergraph/Artistic/node3.png" alt="Contrast">  </p>
<pre><code>float midpoint = pow(0.5, 2.2);
Out =  (In - midpoint) * Contrast + midpoint;
</code></pre>
<h4 id="Hue-色相调节"><a href="#Hue-色相调节" class="headerlink" title="Hue 色相调节"></a>Hue 色相调节</h4><p>根据Offset调节色相。<br>可以根据Degrees调节即（-180，180）<br>或者根据Normalized调节即（-1，1）<br><img src="/img/shadergraph/Artistic/node4.png" alt="HUE"><br>Degree代码（Normalized类似）：</p>
<pre><code>float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
float D = Q.x - min(Q.w, Q.y);
float E = 1e-10;
float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x);

float hue = hsv.x + Offset / 360;
hsv.x = (hue &lt; 0)
        ? hue + 1
        : (hue &gt; 1)
            ? hue - 1
            : hue;

float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
</code></pre>
<h4 id="Invert-Colors-颜色反转"><a href="#Invert-Colors-颜色反转" class="headerlink" title="Invert Colors 颜色反转"></a>Invert Colors 颜色反转</h4><p>可以选择单个或多个反转的通道<br><img src="/img/shadergraph/Artistic/node5.png" alt="Texture">  </p>
<h4 id="Replace-Color-替换颜色"><a href="#Replace-Color-替换颜色" class="headerlink" title="Replace Color 替换颜色"></a>Replace Color 替换颜色</h4><p>In：输入的颜色<br>From：要替换的颜色<br>To：替换成的颜色<br>Range：类似PS里的容差值<br>Fuzziness：软化选区的边缘<br><img src="/img/shadergraph/Artistic/node6.png" alt="Texture">    </p>
<pre><code>float Distance = distance(From, In);
Out = lerp(To, In, saturate((Distance - Range) / max(Fuzziness, 1e-5f)));
</code></pre>
<h4 id="Saturation-饱和度"><a href="#Saturation-饱和度" class="headerlink" title="Saturation 饱和度"></a>Saturation 饱和度</h4><p>Saturation为1时输出原颜色，Saturation为0时为完全不饱和色。<br><img src="/img/shadergraph/Artistic/node7.png" alt="Texture">   </p>
<pre><code>float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
Out =  luma.xxx + Saturation.xxx * (In - luma.xxx);
</code></pre>
<h4 id="White-Balance-白平衡"><a href="#White-Balance-白平衡" class="headerlink" title="White Balance 白平衡"></a>White Balance 白平衡</h4><p>Temperature 让颜色变黄或者变蓝<br>Tint 让颜色变粉或者变绿<br><img src="/img/shadergraph/Artistic/node8.png" alt="Texture">   </p>
<pre><code>// Range ~[-1.67;1.67] works best
float t1 = Temperature * 10 / 6;
float t2 = Tint * 10 / 6;

// Get the CIE xy chromaticity of the reference white point.
// Note: 0.31271 = x value on the D65 white point
float x = 0.31271 - t1 * (t1 &lt; 0 ? 0.1 : 0.05);
float standardIlluminantY = 2.87 * x - 3 * x * x - 0.27509507;
float y = standardIlluminantY + t2 * 0.05;

// Calculate the coefficients in the LMS space.
float3 w1 = float3(0.949237, 1.03542, 1.08728); // D65 white point

// CIExyToLMS
float Y = 1;
float X = Y * x / y;
float Z = Y * (1 - x - y) / y;
float L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z;
float M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z;
float S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z;
float3 w2 = float3(L, M, S);

float3 balance = float3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z);

float3x3 LIN_2_LMS_MAT = &#123;
    3.90405e-1, 5.49941e-1, 8.92632e-3,
    7.08416e-2, 9.63172e-1, 1.35775e-3,
    2.31082e-2, 1.28021e-1, 9.36245e-1
&#125;;

float3x3 LMS_2_LIN_MAT = &#123;
    2.85847e+0, -1.62879e+0, -2.48910e-2,
    -2.10182e-1,  1.15820e+0,  3.24281e-4,
    -4.18120e-2, -1.18169e-1,  1.06867e+0
&#125;;

float3 lms = mul(LIN_2_LMS_MAT, In);
lms *= balance;
Out = mul(LMS_2_LIN_MAT, lms);
</code></pre>
<h3 id="Blend-混合"><a href="#Blend-混合" class="headerlink" title="Blend 混合"></a>Blend 混合</h3><p>根据输入的Base、Blend两个值进行混合，Opacity可以设置混合的强度，0=不增强，Mode可以设置混合的模式。<br><img src="/img/shadergraph/Artistic/node9.png" alt="Texture"><br>不同Mode的Shader代码</p>
<ul>
<li><p>Burn</p>
<pre><code>  Out =  1.0 - (1.0 - Blend)/Base;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Darken</p>
<pre><code>  Out = min(Blend, Base);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Difference</p>
<pre><code>  Out = abs(Blend - Base);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Dodge</p>
<pre><code>  Out = Base / (1.0 - Blend);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Divide</p>
<pre><code>  Out = Base / (Blend + 0.000000000001);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Exclusion</p>
<pre><code>  Out = Blend + Base - (2.0 * Blend * Base);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>HardLight</p>
<pre><code>  float# result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend);
  float# result2 = 2.0 * Base * Blend;
  float# zeroOrOne = step(Blend, 0.5);
  Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>HardMix</p>
<pre><code>  Out = step(1 - Base, Blend);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Lighten</p>
<pre><code>  Out = max(Blend, Base);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>LinearBurn</p>
<pre><code>  Out = Base + Blend - 1.0;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>LinearDodge</p>
<pre><code>  Out = Base + Blend;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>LinearLight</p>
<pre><code>  Out = Blend &lt; 0.5 ? max(Base + (2 * Blend) - 1, 0) : min(Base + 2 * (Blend - 0.5), 1);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>LinearLightAddSub</p>
<pre><code>  Out = Blend + 2.0 * Base - 1.0;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Multiply</p>
<pre><code>  Out = Base * Blend;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Negation</p>
<pre><code>  Out = 1.0 - abs(1.0 - Blend - Base);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Screen</p>
<pre><code>  Out = 1.0 - (1.0 - Blend) * (1.0 - Base);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Overlay</p>
<pre><code>  float# result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend);
  float# result2 = 2.0 * Base * Blend;
  float# zeroOrOne = step(Base, 0.5);
  Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>PinLight</p>
<pre><code>  float# check = step (0.5, Blend);
  float# result1 = check * max(2.0 * (Base - 0.5), Blend);
  Out = result1 + (1.0 - check) * min(2.0 * Base, Blend);
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>SoftLight</p>
<pre><code>  float# result1 = 2.0 * Base * Blend + Base * Base * (1.0 - 2.0 * Blend);
  float# result2 = sqrt(Base) * (2.0 * Blend - 1.0) + 2.0 * Base * (1.0 - Blend);
  float# zeroOrOne = step(0.5, Blend);
  Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>VividLight</p>
<pre><code>  float# result1 = 1.0 - (1.0 - Blend) / (2.0 * Base);
  float# result2 = Blend / (2.0 * (1.0 - Base));
  float# zeroOrOne = step(0.5, Base);
  Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
<li><p>Subtract</p>
<pre><code>  Out = Base - Blend;
  Out = lerp(Base, Out, Opacity);
</code></pre>
</li>
</ul>
<h3 id="Filter-滤镜"><a href="#Filter-滤镜" class="headerlink" title="Filter 滤镜"></a>Filter 滤镜</h3><h4 id="Dither"><a href="#Dither" class="headerlink" title="Dither"></a>Dither</h4><p>Dither 是一种特定格式的噪波，用于随机量化误差。它用于防止大幅拉伸图片时出现的异常情况，如图像中的色带。Dither节点在屏幕空间抖动来确保图案的均匀分布。可以通过连接另一个节点来输入屏幕位置。此节点通常作为主节点上 Alpha Clip Threshold 的输入，为不透明对象提供透明的外观。这对于创建透明的对象很有用，而且仍然可以写入深度缓冲区。  </p>
<p><img src="/img/shadergraph/Artistic/node10.png" alt="Texture">   </p>
<pre><code>float2 uv = ScreenPosition.xy * _ScreenParams.xy;
float DITHER_THRESHOLDS[16] =
&#123;
    1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
    13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
    4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
    16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
&#125;;
uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
Out = In - DITHER_THRESHOLDS[index];
</code></pre>
<h3 id="Mask-遮罩"><a href="#Mask-遮罩" class="headerlink" title="Mask 遮罩"></a>Mask 遮罩</h3><h4 id="Channel-Mask"><a href="#Channel-Mask" class="headerlink" title="Channel Mask"></a>Channel Mask</h4><p>可以从下拉框中选择输出的通道。可以用来过滤或使用某个或某几个通道。<br><img src="/img/shadergraph/Artistic/node11.png" alt="Texture">   </p>
<h4 id="Color-Mask"><a href="#Color-Mask" class="headerlink" title="Color Mask"></a>Color Mask</h4><p>从输入颜色与Mask Color相等的颜色的位置创建一个遮罩。<br>Range：类似PS里的容差值<br>Fuzziness：软化选区的边缘    </p>
<p><img src="/img/shadergraph/Artistic/node12.png" alt="Texture">   </p>
<pre><code>float Distance = distance(MaskColor, In);
Out = saturate(1 - (Distance - Range) / max(Fuzziness, 1e-5));
</code></pre>
<h3 id="Normal-法线"><a href="#Normal-法线" class="headerlink" title="Normal 法线"></a>Normal 法线</h3><h4 id="Normal-Blend-法线混合"><a href="#Normal-Blend-法线混合" class="headerlink" title="Normal Blend 法线混合"></a>Normal Blend 法线混合</h4><p>混合两个法线</p>
<p><img src="/img/shadergraph/Artistic/node13.png" alt="Texture">   </p>
<pre><code>Out = normalize(float3(A.rg + B.rg, A.b * B.b));
</code></pre>
<h4 id="Normal-Create-创建法线"><a href="#Normal-Create-创建法线" class="headerlink" title="Normal Create 创建法线"></a>Normal Create 创建法线</h4><p>从一张高度图Texture创建法线贴图。UV和Sampler可以从对应的UV和Sampler State节点连接，如果没有设置将使用默认值。<br>创建的法线贴图的强度可以用Offset和Strength属性修改。Offset定义了法线细节的最大距离，Strength是结果的系数。<br><img src="/img/shadergraph/Artistic/node14.png" alt="Texture">   </p>
<pre><code>Offset = pow(Offset, 3) * 0.1;
float2 offsetU = float2(UV.x + Offset, UV.y);
float2 offsetV = float2(UV.x, UV.y + Offset);
float normalSample = Texture.Sample(Sampler, UV);
float uSample = Texture.Sample(Sampler, offsetU);
float vSample = Texture.Sample(Sampler, offsetV);
float3 va = float3(1, 0, (uSample - normalSample) * Strength);
float3 vb = float3(0, 1, (vSample - normalSample) * Strength);
Out = normalize(cross(va, vb));
</code></pre>
<h4 id="Normal-Strength"><a href="#Normal-Strength" class="headerlink" title="Normal Strength"></a>Normal Strength</h4><p>修改法线贴图的Strength。Strength为1时返回原图，为0时返回纯黑的法线贴图。<br><img src="/img/shadergraph/Artistic/node15.png" alt="Texture">   </p>
<pre><code>Out = &#123;precision&#125;3(In.rg * Strength, In.b);
</code></pre>
<h4 id="Normal-Unpack"><a href="#Normal-Unpack" class="headerlink" title="Normal Unpack"></a>Normal Unpack</h4><p>解包一个法线贴图。</p>
<ul>
<li>注意<br>通常这是多余的，因为在Sample的时候法线贴图的Type一般会设置为Normal，如下图所示，已经自动解包成法线贴图。可以看下面Normal Unpack节点是多余的，下面预览是相同的。<br><img src="/img/shadergraph/Artistic/node16.png" alt="Texture">   </li>
</ul>
<h3 id="Utility-工具"><a href="#Utility-工具" class="headerlink" title="Utility 工具"></a>Utility 工具</h3><h4 id="Colorspace-Conversion-颜色空间转换"><a href="#Colorspace-Conversion-颜色空间转换" class="headerlink" title="Colorspace Conversion 颜色空间转换"></a>Colorspace Conversion 颜色空间转换</h4><p>从一种颜色空间转换到另一种颜色空间。<br><img src="/img/shadergraph/Artistic/node17.png" alt="Texture">  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Unity3D，Shader</tag>
        <tag>ShaderGraph</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity_ShaderGraph 节点之 Channel Nodes</title>
    <url>/2018/08/24/shadergraph/ShaderGraph_Channel%20Nodes/</url>
    <content><![CDATA[<h3 id="Combine-组合"><a href="#Combine-组合" class="headerlink" title="Combine 组合"></a>Combine 组合</h3><p>可以从 RGBA 重新组合一个新的向量<br><img src="/img/shadergraph/Channel/combine.png" alt="combine"></p>
<pre><code>RGBA = float4(R, G, B, A);
RGB = float3(R, G, B);
RG = float2(R, G);
</code></pre>
<h3 id="Flip-翻转"><a href="#Flip-翻转" class="headerlink" title="Flip 翻转"></a>Flip 翻转</h3><p>反转各个值（变为相反值），可以选择一个或多个通道进行反转。<br><img src="/img/shadergraph/Channel/flip.png" alt="flip"></p>
<h3 id="Split-分割"><a href="#Split-分割" class="headerlink" title="Split 分割"></a>Split 分割</h3><p>将一个多维向量分割成多个1维的数值。如果输入的向量小于4维，不够的维度会使用默认值分别是 (0, 0, 0, 1)。<br><img src="/img/shadergraph/Channel/split.png" alt="split"></p>
<h3 id="Swizzle-打乱"><a href="#Swizzle-打乱" class="headerlink" title="Swizzle 打乱"></a>Swizzle 打乱</h3><p>从输入的向量创建一个新的向量，但是可以根据下拉参数打乱输出的维度。<br><img src="/img/shadergraph/Channel/swizzle.png" alt="swizzle"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>ShaderGraph</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
</search>
